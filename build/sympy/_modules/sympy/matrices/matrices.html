

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>sympy.matrices.matrices &mdash; SymPy v0.7.1 documentation</title>
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.7.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <link rel="top" title="SymPy v0.7.1 documentation" href="../../../index.html" />
    <link rel="up" title="sympy" href="../../sympy.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SymPy v0.7.1 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../sympy.html" accesskey="U">sympy</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for sympy.matrices.matrices</h1><div class="highlight"><pre>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Basic</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Dummy</span><span class="p">,</span> <span class="n">Rational</span><span class="p">,</span> <span class="n">Add</span><span class="p">,</span> <span class="n">Pow</span>
<span class="kn">from</span> <span class="nn">sympy.core.numbers</span> <span class="kn">import</span> <span class="n">Zero</span>
<span class="kn">from</span> <span class="nn">sympy.core.sympify</span> <span class="kn">import</span> <span class="n">sympify</span><span class="p">,</span> <span class="n">converter</span><span class="p">,</span> <span class="n">SympifyError</span>
<span class="kn">from</span> <span class="nn">sympy.core.compatibility</span> <span class="kn">import</span> <span class="n">is_sequence</span>

<span class="kn">from</span> <span class="nn">sympy.polys</span> <span class="kn">import</span> <span class="n">Poly</span><span class="p">,</span> <span class="n">roots</span><span class="p">,</span> <span class="n">cancel</span>
<span class="kn">from</span> <span class="nn">sympy.simplify</span> <span class="kn">import</span> <span class="n">simplify</span> <span class="k">as</span> <span class="n">sympy_simplify</span>
<span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">flatten</span>
<span class="kn">from</span> <span class="nn">sympy.functions.elementary.miscellaneous</span> <span class="kn">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">Max</span><span class="p">,</span> <span class="n">Min</span>
<span class="kn">from</span> <span class="nn">sympy.functions.elementary.complexes</span> <span class="kn">import</span> <span class="n">re</span><span class="p">,</span> <span class="n">Abs</span>
<span class="kn">from</span> <span class="nn">sympy.printing</span> <span class="kn">import</span> <span class="n">sstr</span>

<span class="kn">from</span> <span class="nn">sympy.core.compatibility</span> <span class="kn">import</span> <span class="nb">callable</span><span class="p">,</span> <span class="nb">reduce</span>

<span class="kn">import</span> <span class="nn">random</span>

<span class="k">class</span> <span class="nc">MatrixError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">ShapeError</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="n">MatrixError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wrong matrix shape&quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">NonSquareMatrixError</span><span class="p">(</span><span class="n">ShapeError</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">_dims_to_nm</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converts dimensions tuple (or any object with length 1 or 2) or scalar</span>
<span class="sd">    in dims to matrix dimensions n and m.&quot;&quot;&quot;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="p">(</span><span class="n">dims</span><span class="p">,)</span>
        <span class="n">l</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c"># This will work for nd-array too when they are added to sympy.</span>
    <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Matrix dimensions should be non-negative integers.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Matrix dimensions should be a two-element tuple of ints or a single int!&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span>

<span class="k">def</span> <span class="nf">_iszero</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns True if x is zero.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">is_zero</span>


<span class="k">class</span> <span class="nc">DeferredVector</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">=</span><span class="n">name</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>
        <span class="n">component_name</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">[</span><span class="si">%d</span><span class="s">]&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">component_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sstr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sstr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<div class="viewcode-block" id="Matrix"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix">[docs]</a><span class="k">class</span> <span class="nc">Matrix</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="c"># Added just for numpy compatibility</span>
    <span class="c"># TODO: investigate about __array_priority__</span>
    <span class="n">__array_priority__</span> <span class="o">=</span> <span class="mf">10.0</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Matrix can be constructed with values or a rule.</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix, I</span>
<span class="sd">        &gt;&gt;&gt; Matrix( ((1,2+I), (3,4)) ) #doctest:+NORMALIZE_WHITESPACE</span>
<span class="sd">        [1, 2 + I]</span>
<span class="sd">        [3,     4]</span>
<span class="sd">        &gt;&gt;&gt; Matrix(2, 2, lambda i,j: (i+1)*j ) #doctest:+NORMALIZE_WHITESPACE</span>
<span class="sd">        [0, 1]</span>
<span class="sd">        [0, 2]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="nb">callable</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
            <span class="n">operation</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mat</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sympify</span><span class="p">(</span><span class="n">operation</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span> <span class="ow">and</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="o">=</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="o">=</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;List length should be equal to rows*columns&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mat</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">sympify</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">mat</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">rows</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">cols</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[:]</span>
                <span class="k">return</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="s">&quot;__array__&quot;</span><span class="p">):</span>
                <span class="c"># NumPy array or matrix or some other object that implements</span>
                <span class="c"># __array__. So let&#39;s first use this method to get a</span>
                <span class="c"># numpy.array() and then make a python list out of it.</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">__array__</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mat</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">sympify</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">arr</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
                    <span class="k">return</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mat</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">return</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Sympy supports just 1D and 2D matrices&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="n">Matrix</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Matrix constructor doesn&#39;t accept </span><span class="si">%s</span><span class="s"> as input&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">mat</span><span class="p">)))</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">):</span>
                    <span class="n">mat</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mat</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">sympify</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">mat</span><span class="p">)</span>
                    <span class="k">return</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mat</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Input </span><span class="si">%s</span><span class="s"> inconsistant to form a Matrix.&quot;</span> <span class="o">%</span>
                        <span class="n">args</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sympify</span><span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c"># Empty Matrix</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mat</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Data type not understood&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Matrix.key2ij"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.key2ij">[docs]</a>    <span class="k">def</span> <span class="nf">key2ij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts key=(4,6) to 4,6 and ensures the key is correct.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">is_sequence</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;wrong syntax: a[</span><span class="si">%s</span><span class="s">]. Use a[i,j] or a[(i,j)]&quot;</span>
                    <span class="o">%</span><span class="nb">repr</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
        <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="n">key</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span><span class="o">&lt;</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="ow">and</span> <span class="n">j</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
            <span class="k">print</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s">&quot;Index out of range: a[</span><span class="si">%s</span><span class="s">]&quot;</span><span class="o">%</span><span class="nb">repr</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span>
</div>
<div class="viewcode-block" id="Matrix.transpose"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.transpose">[docs]</a>    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Matrix transposition.</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix, I</span>
<span class="sd">        &gt;&gt;&gt; m=Matrix(((1,2+I),(3,4)))</span>
<span class="sd">        &gt;&gt;&gt; m  #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        [1, 2 + I]</span>
<span class="sd">        [3,     4]</span>
<span class="sd">        &gt;&gt;&gt; m.transpose() #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        [    1, 3]</span>
<span class="sd">        [2 + I, 4]</span>
<span class="sd">        &gt;&gt;&gt; m.T == m.transpose()</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
            <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">::</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span><span class="n">a</span><span class="p">)</span>
</div>
    <span class="n">T</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">transpose</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="s">&quot;Matrix transposition.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Matrix.conjugate"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.conjugate">[docs]</a>    <span class="k">def</span> <span class="nf">conjugate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;By-element conjugation.&quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span>
                <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">:</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">out</span>
</div>
    <span class="n">C</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">conjugate</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="s">&quot;By-element conjugation.&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="Matrix.H"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.H">[docs]</a>    <span class="k">def</span> <span class="nf">H</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Hermite conjugation.</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix, I</span>
<span class="sd">        &gt;&gt;&gt; m=Matrix(((1,2+I),(3,4)))</span>
<span class="sd">        &gt;&gt;&gt; m  #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        [1, 2 + I]</span>
<span class="sd">        [3,     4]</span>
<span class="sd">        &gt;&gt;&gt; m.H #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        [    1, 3]</span>
<span class="sd">        [2 - I, 4]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">C</span>
        <span class="k">return</span> <span class="n">out</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Matrix.D"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.D">[docs]</a>    <span class="k">def</span> <span class="nf">D</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dirac conjugation.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.physics.matrices</span> <span class="kn">import</span> <span class="n">mgamma</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span> <span class="o">*</span> <span class="n">mgamma</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>
</div>
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; from sympy import Matrix, I</span>
<span class="sd">        &gt;&gt;&gt; m=Matrix(((1,2+I),(3,4)))</span>
<span class="sd">        &gt;&gt;&gt; m  #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        [1, 2 + I]</span>
<span class="sd">        [3,     4]</span>
<span class="sd">        &gt;&gt;&gt; m[1,0]</span>
<span class="sd">        3</span>
<span class="sd">        &gt;&gt;&gt; m.H[1,0]</span>
<span class="sd">        2 - I</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">key</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">slice</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">slice</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">submatrix</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c"># a2idx inlined</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">__index__</span><span class="p">()</span>
                    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s">&quot;Invalid index a[</span><span class="si">%r</span><span class="s">]&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,))</span>
                <span class="c"># a2idx inlined</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                       <span class="n">j</span> <span class="o">=</span> <span class="n">j</span><span class="o">.</span><span class="n">__index__</span><span class="p">()</span>
                    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s">&quot;Invalid index a[</span><span class="si">%r</span><span class="s">]&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,))</span>


                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span><span class="o">&lt;</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="ow">and</span> <span class="n">j</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s">&quot;Index out of range: a[</span><span class="si">%s</span><span class="s">]&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span>


        <span class="k">else</span><span class="p">:</span>
            <span class="c"># row-wise decomposition of matrix</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">slice</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">a2idx</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s">&quot;Invalid index: a[</span><span class="si">%s</span><span class="s">]&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; from sympy import Matrix, I</span>
<span class="sd">        &gt;&gt;&gt; m=Matrix(((1,2+I),(3,4)))</span>
<span class="sd">        &gt;&gt;&gt; m  #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        [1, 2 + I]</span>
<span class="sd">        [3,     4]</span>
<span class="sd">        &gt;&gt;&gt; m[1,0]=9</span>
<span class="sd">        &gt;&gt;&gt; m  #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        [1, 2 + I]</span>
<span class="sd">        [9,     4]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">key</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">slice</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">slice</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">copyin_matrix</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                    <span class="k">return</span>
                <span class="k">if</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">copyin_list</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                    <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># a2idx inlined</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">__index__</span><span class="p">()</span>
                    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s">&quot;Invalid index a[</span><span class="si">%r</span><span class="s">]&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,))</span>

                <span class="c"># a2idx inlined</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">j</span> <span class="o">=</span> <span class="n">j</span><span class="o">.</span><span class="n">__index__</span><span class="p">()</span>
                    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s">&quot;Invalid index a[</span><span class="si">%r</span><span class="s">]&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,))</span>


                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span><span class="o">&lt;</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="ow">and</span> <span class="n">j</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s">&quot;Index out of range: a[</span><span class="si">%s</span><span class="s">]&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                    <span class="k">return</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c"># row-wise decomposition of matrix</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">slice</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s">&quot;Vector slices not implemented yet.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">a2idx</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                    <span class="k">return</span>
        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s">&quot;Invalid index: a[</span><span class="si">%s</span><span class="s">]&quot;</span><span class="o">%</span><span class="nb">repr</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">matrix2numpy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of elements of self.</span>

<span class="sd">        Implemented mainly so bool(Matrix()) == False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span>

<div class="viewcode-block" id="Matrix.tolist"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.tolist">[docs]</a>    <span class="k">def</span> <span class="nf">tolist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the Matrix converted in a python list.</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; m=Matrix(3, 3, range(9))</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        [0, 1, 2]</span>
<span class="sd">        [3, 4, 5]</span>
<span class="sd">        [6, 7, 8]</span>
<span class="sd">        &gt;&gt;&gt; m.tolist()</span>
<span class="sd">        [[0, 1, 2], [3, 4, 5], [6, 7, 8]]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
            <span class="n">ret</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ret</span>
</div>
    <span class="k">def</span> <span class="nf">copyin_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">rlo</span><span class="p">,</span> <span class="n">rhi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice2bounds</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">)</span>
        <span class="n">clo</span><span class="p">,</span> <span class="n">chi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice2bounds</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">rows</span> <span class="o">!=</span> <span class="n">rhi</span> <span class="o">-</span> <span class="n">rlo</span> <span class="ow">or</span> <span class="n">value</span><span class="o">.</span><span class="n">cols</span> <span class="o">!=</span> <span class="n">chi</span> <span class="o">-</span> <span class="n">clo</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ShapeError</span><span class="p">(</span><span class="s">&quot;The Matrix `value` doesn&#39;t have the same dimensions &quot;</span> <span class="o">+</span>
                <span class="s">&quot;as the in sub-Matrix given by `key`.&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">rlo</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="n">clo</span><span class="p">]</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">copyin_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;`value` must be an ordered iterable, not </span><span class="si">%s</span><span class="s">.&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copyin_matrix</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

<div class="viewcode-block" id="Matrix.hash"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.hash">[docs]</a>    <span class="k">def</span> <span class="nf">hash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute a hash every time, because the matrix elements</span>
<span class="sd">        could change.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__str__</span><span class="p">()</span> <span class="p">)</span>
</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">a</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&quot;__array__&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">():</span>
            <span class="k">return</span> <span class="n">matrix_multiply</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">a</span><span class="o">*</span><span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">expand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">i</span><span class="o">.</span><span class="n">expand</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">combine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">i</span><span class="o">.</span><span class="n">combine</span><span class="p">(),</span><span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">subs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">i</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">a</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">a</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&quot;__array__&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">():</span>
            <span class="k">return</span> <span class="n">matrix_multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">a</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">i</span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">Integer</span><span class="p">):</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span> <span class="o">**</span> <span class="o">-</span><span class="n">n</span>   <span class="c"># A**-2 = (A**-1)**2</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">while</span> <span class="n">n</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n</span><span class="o">%</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">a</span> <span class="o">*=</span> <span class="n">s</span>
                    <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">s</span> <span class="o">*=</span> <span class="n">s</span>
                <span class="n">n</span> <span class="o">//=</span> <span class="mi">2</span>
            <span class="k">return</span> <span class="n">a</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">Rational</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">P</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diagonalize</span><span class="p">()</span>
            <span class="k">except</span> <span class="n">MatrixError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Implemented only for diagonalizable matrices&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
                <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="n">num</span>
            <span class="k">return</span> <span class="n">P</span> <span class="o">*</span> <span class="n">D</span> <span class="o">*</span> <span class="n">P</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Only integer and rational values are supported&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">a</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">matrix_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">a</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">a</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">matrix_add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">a</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">*</span> <span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="o">/</span><span class="n">a</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">a</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__div__</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<div class="viewcode-block" id="Matrix.multiply"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.multiply">[docs]</a>    <span class="k">def</span> <span class="nf">multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns self*b &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">matrix_multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Matrix.add"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return self+b &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">matrix_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="n">Matrix</span><span class="p">,</span> <span class="n">Basic</span><span class="p">)):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="n">Matrix</span><span class="p">,</span> <span class="n">Basic</span><span class="p">)):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Matrix</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__hash__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_format_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strfunc</span><span class="p">,</span> <span class="n">rowsep</span><span class="o">=</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">):</span>
        <span class="c"># Handle zero dimensions:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&#39;[]&#39;</span>
        <span class="c"># Build table of string representations of the elements</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c"># Track per-column max lengths for pretty alignment</span>
        <span class="n">maxlen</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
                <span class="n">string</span> <span class="o">=</span> <span class="n">strfunc</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span>
                <span class="n">res</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
                <span class="n">maxlen</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">string</span><span class="p">),</span> <span class="n">maxlen</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="c"># Patch strings together</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">res</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">elem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
                <span class="c"># Pad each element up to maxlen so the columns line up</span>
                <span class="n">row</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">elem</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="n">maxlen</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;[&quot;</span> <span class="o">+</span> <span class="s">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;]&quot;</span>
        <span class="k">return</span> <span class="n">rowsep</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sstr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sstr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="Matrix.cholesky"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.cholesky">[docs]</a>    <span class="k">def</span> <span class="nf">cholesky</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the Cholesky Decomposition L of a Matrix A</span>
<span class="sd">        such that L * L.T = A</span>

<span class="sd">        A must be a square, symmetric, positive-definite</span>
<span class="sd">        and non-singular matrix</span>

<span class="sd">        &gt;&gt;&gt; from sympy.matrices import Matrix</span>
<span class="sd">        &gt;&gt;&gt; A = Matrix(((25,15,-5),(15,18,0),(-5,0,11)))</span>
<span class="sd">        &gt;&gt;&gt; A.cholesky()</span>
<span class="sd">        [ 5, 0, 0]</span>
<span class="sd">        [ 3, 3, 0]</span>
<span class="sd">        [-1, 1, 3]</span>
<span class="sd">        &gt;&gt;&gt; A.cholesky() * A.cholesky().T</span>
<span class="sd">        [25, 15, -5]</span>
<span class="sd">        [15, 18,  0]</span>
<span class="sd">        [-5,  0, 11]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">(</span><span class="s">&quot;Matrix must be square.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_symmetric</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Matrix must be symmetric.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cholesky</span><span class="p">()</span>
</div>
    <span class="k">def</span> <span class="nf">_cholesky</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function of cholesky.</span>
<span class="sd">        Without the error checks.</span>
<span class="sd">        To be used privately. &quot;&quot;&quot;</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">j</span><span class="p">)))</span>
            <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span> <span class="o">**</span> <span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">L</span>

<div class="viewcode-block" id="Matrix.LDLdecomposition"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.LDLdecomposition">[docs]</a>    <span class="k">def</span> <span class="nf">LDLdecomposition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the LDL Decomposition (L,D) of matrix A,</span>
<span class="sd">        such that L * D * L.T == A</span>
<span class="sd">        This method eliminates the use of square root.</span>
<span class="sd">        Further this ensures that all the diagonal entries of L are 1.</span>
<span class="sd">        A must be a square, symmetric, positive-definite</span>
<span class="sd">        and non-singular matrix.</span>

<span class="sd">        &gt;&gt;&gt; from sympy.matrices import Matrix, eye</span>
<span class="sd">        &gt;&gt;&gt; A = Matrix(((25,15,-5),(15,18,0),(-5,0,11)))</span>
<span class="sd">        &gt;&gt;&gt; L, D = A.LDLdecomposition()</span>
<span class="sd">        &gt;&gt;&gt; L</span>
<span class="sd">        [   1,   0, 0]</span>
<span class="sd">        [ 3/5,   1, 0]</span>
<span class="sd">        [-1/5, 1/3, 1]</span>
<span class="sd">        &gt;&gt;&gt; D</span>
<span class="sd">        [25, 0, 0]</span>
<span class="sd">        [ 0, 9, 0]</span>
<span class="sd">        [ 0, 0, 9]</span>
<span class="sd">        &gt;&gt;&gt; L * D * L.T * A.inv() == eye(A.rows)</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixException</span><span class="p">(</span><span class="s">&quot;Matrix must be square.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_symmetric</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Matrix must be symmetric.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_LDLdecomposition</span><span class="p">()</span>
</div>
    <span class="k">def</span> <span class="nf">_LDLdecomposition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function of LDLdecomposition.</span>
<span class="sd">        Without the error checks.</span>
<span class="sd">        To be used privately.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">))</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span>
                    <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">D</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">j</span><span class="p">)))</span>
            <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">D</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">L</span><span class="p">,</span> <span class="n">D</span>

<div class="viewcode-block" id="Matrix.lower_triangular_solve"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.lower_triangular_solve">[docs]</a>    <span class="k">def</span> <span class="nf">lower_triangular_solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solves Ax = B, where A is a lower triangular matrix.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixException</span><span class="p">(</span><span class="s">&quot;Matrix must be square.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rhs</span><span class="o">.</span><span class="n">rows</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ShapeError</span><span class="p">(</span><span class="s">&quot;Matrices size mismatch.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_lower</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Matrix must be lower triangular.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lower_triangular_solve</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_lower_triangular_solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function of function lower_triangular_solve.</span>
<span class="sd">        Without the error checks.</span>
<span class="sd">        To be used privately.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Matrix must be non-singular.&quot;</span><span class="p">)</span>
            <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">rhs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">X</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span> <span class="o">/</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">X</span>

<div class="viewcode-block" id="Matrix.upper_triangular_solve"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.upper_triangular_solve">[docs]</a>    <span class="k">def</span> <span class="nf">upper_triangular_solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solves Ax = B, where A is an upper triangular matrix.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixException</span><span class="p">(</span><span class="s">&quot;Matrix must be square.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rhs</span><span class="o">.</span><span class="n">rows</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Matrix size mismatch.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_upper</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Matrix is not upper triangular.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_upper_triangular_solve</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_upper_triangular_solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function of function upper_triangular_solve.</span>
<span class="sd">        Without the error checks, to be used privately. &quot;&quot;&quot;</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Matrix must be non-singular.&quot;</span><span class="p">)</span>
            <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">rhs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">X</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">)))</span> <span class="o">/</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">X</span>

<div class="viewcode-block" id="Matrix.cholesky_solve"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.cholesky_solve">[docs]</a>    <span class="k">def</span> <span class="nf">cholesky_solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solves Ax = B using Cholesky decomposition,</span>
<span class="sd">        for a general square non-singular matrix.</span>
<span class="sd">        For a non-square matrix with rows &gt; cols,</span>
<span class="sd">        the least squares solution is returned.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_symmetric</span><span class="p">():</span>
            <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cholesky</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
            <span class="n">L</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_cholesky</span><span class="p">()</span>
            <span class="n">rhs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">rhs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Under-determined System.&quot;</span><span class="p">)</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">_lower_triangular_solve</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">_upper_triangular_solve</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Matrix.diagonal_solve"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.diagonal_solve">[docs]</a>    <span class="k">def</span> <span class="nf">diagonal_solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solves Ax = B efficiently, where A is a diagonal Matrix,</span>
<span class="sd">        with non-zero diagonal entries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_diagonal</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Matrix should be diagonal&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rhs</span><span class="o">.</span><span class="n">rows</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Size mis-match&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_diagonal_solve</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_diagonal_solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function of function diagonal_solve,</span>
<span class="sd">        without the error checks, to be used privately.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">rhs</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">rhs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>

<div class="viewcode-block" id="Matrix.LDLsolve"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.LDLsolve">[docs]</a>    <span class="k">def</span> <span class="nf">LDLsolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solves Ax = B using LDL decomposition,</span>
<span class="sd">        for a general square and non-singular matrix.</span>

<span class="sd">        For a non-square matrix with rows &gt; cols,</span>
<span class="sd">        the least squares solution is returned.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_symmetric</span><span class="p">():</span>
            <span class="n">L</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LDLdecomposition</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
            <span class="n">L</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">LDLdecomposition</span><span class="p">()</span>
            <span class="n">rhs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">rhs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Under-determined System.&quot;</span><span class="p">)</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">_lower_triangular_solve</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">_diagonal_solve</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">_upper_triangular_solve</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Matrix.inv"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.inv">[docs]</a>    <span class="k">def</span> <span class="nf">inv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&quot;GE&quot;</span><span class="p">,</span> <span class="n">iszerofunc</span><span class="o">=</span><span class="n">_iszero</span><span class="p">,</span> <span class="n">try_block_diag</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the matrix inverse.</span>

<span class="sd">        According to the &quot;method&quot; parameter, it calls the appropriate method:</span>

<span class="sd">          GE .... inverse_GE()</span>
<span class="sd">          LU .... inverse_LU()</span>
<span class="sd">          ADJ ... inverse_ADJ()</span>

<span class="sd">        According to the &quot;try_block_diag&quot; parameter, it will try to form block</span>
<span class="sd">        diagonal matrices using the method get_diag_blocks(), invert these</span>
<span class="sd">        individually, and then reconstruct the full inverse matrix.</span>

<span class="sd">        Note, the GE and LU methods may require the matrix to be simplified</span>
<span class="sd">        before it is inverted in order to properly detect zeros during</span>
<span class="sd">        pivoting. In difficult cases a custom zero detection function can</span>
<span class="sd">        be provided by setting the iszerosfunc argument to a function that</span>
<span class="sd">        should return True if its argument is zero.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">try_block_diag</span><span class="p">:</span>
            <span class="n">blocks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_diag_blocks</span><span class="p">()</span>
            <span class="n">r</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">blocks</span><span class="p">:</span>
                <span class="n">r</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">iszerofunc</span><span class="o">=</span><span class="n">iszerofunc</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">diag</span><span class="p">(</span><span class="o">*</span><span class="n">r</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&quot;GE&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverse_GE</span><span class="p">(</span><span class="n">iszerofunc</span><span class="o">=</span><span class="n">iszerofunc</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&quot;LU&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverse_LU</span><span class="p">(</span><span class="n">iszerofunc</span><span class="o">=</span><span class="n">iszerofunc</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&quot;ADJ&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverse_ADJ</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Inversion method unrecognized&quot;</span><span class="p">)</span>

</div>
    <span class="k">def</span> <span class="nf">__mathml__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">mml</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
            <span class="n">mml</span> <span class="o">+=</span> <span class="s">&quot;&lt;matrixrow&gt;&quot;</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
                <span class="n">mml</span> <span class="o">+=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">__mathml__</span><span class="p">()</span>
            <span class="n">mml</span> <span class="o">+=</span> <span class="s">&quot;&lt;/matrixrow&gt;&quot;</span>
        <span class="k">return</span> <span class="s">&quot;&lt;matrix&gt;&quot;</span> <span class="o">+</span> <span class="n">mml</span> <span class="o">+</span> <span class="s">&quot;&lt;/matrix&gt;&quot;</span>

<div class="viewcode-block" id="Matrix.row"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.row">[docs]</a>    <span class="k">def</span> <span class="nf">row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Elementary row operation using functor</span>

<span class="sd">        &gt;&gt;&gt; from sympy import ones</span>
<span class="sd">        &gt;&gt;&gt; I = ones(3)</span>
<span class="sd">        &gt;&gt;&gt; I.row(1,lambda i,j: i*3)</span>
<span class="sd">        &gt;&gt;&gt; I</span>
<span class="sd">        [1, 1, 1]</span>
<span class="sd">        [3, 3, 3]</span>
<span class="sd">        [1, 1, 1]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">j</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Matrix.col"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.col">[docs]</a>    <span class="k">def</span> <span class="nf">col</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Elementary column operation using functor</span>

<span class="sd">        &gt;&gt;&gt; from sympy import ones</span>
<span class="sd">        &gt;&gt;&gt; I = ones(3)</span>
<span class="sd">        &gt;&gt;&gt; I.col(0,lambda i,j: i*3)</span>
<span class="sd">        &gt;&gt;&gt; I</span>
<span class="sd">        [3, 1, 1]</span>
<span class="sd">        [3, 1, 1]</span>
<span class="sd">        [3, 1, 1]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">row_swap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">col_swap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">row_del</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">[:</span><span class="n">i</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">-=</span> <span class="mi">1</span>

<div class="viewcode-block" id="Matrix.col_del"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.col_del">[docs]</a>    <span class="k">def</span> <span class="nf">col_del</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; import sympy</span>
<span class="sd">        &gt;&gt;&gt; M = sympy.matrices.eye(3)</span>
<span class="sd">        &gt;&gt;&gt; M.col_del(1)</span>
<span class="sd">        &gt;&gt;&gt; M   #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        [1, 0]</span>
<span class="sd">        [0, 0]</span>
<span class="sd">        [0, 1]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">-=</span> <span class="mi">1</span>
</div>
<div class="viewcode-block" id="Matrix.row_join"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.row_join">[docs]</a>    <span class="k">def</span> <span class="nf">row_join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concatenates two matrices along self&#39;s last and rhs&#39;s first column</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; M = Matrix(3,3,lambda i,j: i+j)</span>
<span class="sd">        &gt;&gt;&gt; V = Matrix(3,1,lambda i,j: 3+i+j)</span>
<span class="sd">        &gt;&gt;&gt; M.row_join(V)</span>
<span class="sd">        [0, 1, 2, 3]</span>
<span class="sd">        [1, 2, 3, 4]</span>
<span class="sd">        [2, 3, 4, 5]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">!=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ShapeError</span><span class="p">(</span><span class="s">&quot;`self` and `rhs` must have the same number of rows.&quot;</span><span class="p">)</span>

        <span class="n">newmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">+</span> <span class="n">rhs</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>
        <span class="n">newmat</span><span class="p">[:,:</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[:,:]</span>
        <span class="n">newmat</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">:]</span> <span class="o">=</span> <span class="n">rhs</span>
        <span class="k">return</span> <span class="n">newmat</span>
</div>
<div class="viewcode-block" id="Matrix.col_join"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.col_join">[docs]</a>    <span class="k">def</span> <span class="nf">col_join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bott</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concatenates two matrices along self&#39;s last and bott&#39;s first row</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; M = Matrix(3,3,lambda i,j: i+j)</span>
<span class="sd">        &gt;&gt;&gt; V = Matrix(1,3,lambda i,j: 3+i+j)</span>
<span class="sd">        &gt;&gt;&gt; M.col_join(V)</span>
<span class="sd">        [0, 1, 2]</span>
<span class="sd">        [1, 2, 3]</span>
<span class="sd">        [2, 3, 4]</span>
<span class="sd">        [3, 4, 5]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">!=</span> <span class="n">bott</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ShapeError</span><span class="p">(</span><span class="s">&quot;`self` and `bott` must have the same number of columns.&quot;</span><span class="p">)</span>

        <span class="n">newmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="o">+</span><span class="n">bott</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>
        <span class="n">newmat</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,:]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[:,:]</span>
        <span class="n">newmat</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">:,:]</span> <span class="o">=</span> <span class="n">bott</span>
        <span class="k">return</span> <span class="n">newmat</span>
</div>
<div class="viewcode-block" id="Matrix.row_insert"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.row_insert">[docs]</a>    <span class="k">def</span> <span class="nf">row_insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">mti</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; from sympy import Matrix, zeros</span>
<span class="sd">        &gt;&gt;&gt; M = Matrix(3,3,lambda i,j: i+j)</span>
<span class="sd">        &gt;&gt;&gt; M</span>
<span class="sd">        [0, 1, 2]</span>
<span class="sd">        [1, 2, 3]</span>
<span class="sd">        [2, 3, 4]</span>
<span class="sd">        &gt;&gt;&gt; V = zeros((1, 3))</span>
<span class="sd">        &gt;&gt;&gt; V</span>
<span class="sd">        [0, 0, 0]</span>
<span class="sd">        &gt;&gt;&gt; M.row_insert(1,V)</span>
<span class="sd">        [0, 1, 2]</span>
<span class="sd">        [0, 0, 0]</span>
<span class="sd">        [1, 2, 3]</span>
<span class="sd">        [2, 3, 4]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mti</span><span class="o">.</span><span class="n">col_join</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">!=</span> <span class="n">mti</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ShapeError</span><span class="p">(</span><span class="s">&quot;`self` and `mti` must have the same number of columns.&quot;</span><span class="p">)</span>

        <span class="n">newmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">+</span> <span class="n">mti</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>
        <span class="n">newmat</span><span class="p">[:</span><span class="n">pos</span><span class="p">,:]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[:</span><span class="n">pos</span><span class="p">,:]</span>
        <span class="n">newmat</span><span class="p">[</span><span class="n">pos</span><span class="p">:</span><span class="n">pos</span><span class="o">+</span><span class="n">mti</span><span class="o">.</span><span class="n">rows</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">mti</span><span class="p">[:,:]</span>
        <span class="n">newmat</span><span class="p">[</span><span class="n">pos</span><span class="o">+</span><span class="n">mti</span><span class="o">.</span><span class="n">rows</span><span class="p">:,:]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">pos</span><span class="p">:,:]</span>
        <span class="k">return</span> <span class="n">newmat</span>
</div>
<div class="viewcode-block" id="Matrix.col_insert"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.col_insert">[docs]</a>    <span class="k">def</span> <span class="nf">col_insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">mti</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; from sympy import Matrix, zeros</span>
<span class="sd">        &gt;&gt;&gt; M = Matrix(3,3,lambda i,j: i+j)</span>
<span class="sd">        &gt;&gt;&gt; M</span>
<span class="sd">        [0, 1, 2]</span>
<span class="sd">        [1, 2, 3]</span>
<span class="sd">        [2, 3, 4]</span>
<span class="sd">        &gt;&gt;&gt; V = zeros((3, 1))</span>
<span class="sd">        &gt;&gt;&gt; V</span>
<span class="sd">        [0]</span>
<span class="sd">        [0]</span>
<span class="sd">        [0]</span>
<span class="sd">        &gt;&gt;&gt; M.col_insert(1,V)</span>
<span class="sd">        [0, 0, 1, 2]</span>
<span class="sd">        [1, 0, 2, 3]</span>
<span class="sd">        [2, 0, 3, 4]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mti</span><span class="o">.</span><span class="n">row_join</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">!=</span> <span class="n">mti</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ShapeError</span><span class="p">(</span><span class="s">&quot;self and mti must have the same number of rows.&quot;</span><span class="p">)</span>

        <span class="n">newmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">+</span> <span class="n">mti</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>
        <span class="n">newmat</span><span class="p">[:,:</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[:,:</span><span class="n">pos</span><span class="p">]</span>
        <span class="n">newmat</span><span class="p">[:,</span><span class="n">pos</span><span class="p">:</span><span class="n">pos</span><span class="o">+</span><span class="n">mti</span><span class="o">.</span><span class="n">cols</span><span class="p">]</span> <span class="o">=</span> <span class="n">mti</span><span class="p">[:,:]</span>
        <span class="n">newmat</span><span class="p">[:,</span><span class="n">pos</span><span class="o">+</span><span class="n">mti</span><span class="o">.</span><span class="n">cols</span><span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[:,</span><span class="n">pos</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">newmat</span>
</div>
    <span class="k">def</span> <span class="nf">trace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">()</span>

        <span class="n">trace</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
            <span class="n">trace</span> <span class="o">+=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">trace</span>

<div class="viewcode-block" id="Matrix.submatrix"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.submatrix">[docs]</a>    <span class="k">def</span> <span class="nf">submatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(4,4,lambda i,j: i+j)</span>
<span class="sd">        &gt;&gt;&gt; m   #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        [0, 1, 2, 3]</span>
<span class="sd">        [1, 2, 3, 4]</span>
<span class="sd">        [2, 3, 4, 5]</span>
<span class="sd">        [3, 4, 5, 6]</span>
<span class="sd">        &gt;&gt;&gt; m[0:1, 1]   #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        [1]</span>
<span class="sd">        &gt;&gt;&gt; m[0:2, 0:1] #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        [0]</span>
<span class="sd">        [1]</span>
<span class="sd">        &gt;&gt;&gt; m[2:4, 2:4] #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        [4, 5]</span>
<span class="sd">        [5, 6]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">slice</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;At least one element of `keys` must be a slice object.&quot;</span><span class="p">)</span>

        <span class="n">rlo</span><span class="p">,</span> <span class="n">rhi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice2bounds</span><span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">)</span>
        <span class="n">clo</span><span class="p">,</span> <span class="n">chi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice2bounds</span><span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span> <span class="mi">0</span><span class="o">&lt;=</span><span class="n">rlo</span><span class="o">&lt;=</span><span class="n">rhi</span> <span class="ow">and</span> <span class="mi">0</span><span class="o">&lt;=</span><span class="n">clo</span><span class="o">&lt;=</span><span class="n">chi</span> <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s">&quot;Slice indices out of range: a[</span><span class="si">%s</span><span class="s">]&quot;</span><span class="o">%</span><span class="nb">repr</span><span class="p">(</span><span class="n">keys</span><span class="p">))</span>
        <span class="n">outLines</span><span class="p">,</span> <span class="n">outCols</span> <span class="o">=</span> <span class="n">rhi</span><span class="o">-</span><span class="n">rlo</span><span class="p">,</span> <span class="n">chi</span><span class="o">-</span><span class="n">clo</span>
        <span class="n">outMat</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">outLines</span><span class="o">*</span><span class="n">outCols</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">outLines</span><span class="p">):</span>
            <span class="n">outMat</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">outCols</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">outCols</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="n">rlo</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="o">+</span><span class="n">clo</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="n">rlo</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="o">+</span><span class="n">chi</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">outLines</span><span class="p">,</span><span class="n">outCols</span><span class="p">,</span><span class="n">outMat</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Matrix.extract"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.extract">[docs]</a>    <span class="k">def</span> <span class="nf">extract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rowsList</span><span class="p">,</span> <span class="n">colsList</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract a submatrix by specifying a list of rows and columns</span>

<span class="sd">        Examples:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(4, 3, lambda i, j: i*3 + j)</span>
<span class="sd">        &gt;&gt;&gt; m   #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        [0,  1,  2]</span>
<span class="sd">        [3,  4,  5]</span>
<span class="sd">        [6,  7,  8]</span>
<span class="sd">        [9, 10, 11]</span>
<span class="sd">        &gt;&gt;&gt; m.extract([0,1,3],[0,1])   #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        [0,  1]</span>
<span class="sd">        [3,  4]</span>
<span class="sd">        [9, 10]</span>

<span class="sd">        See also: .submatrix()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mat</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">rows</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rowsList</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s">&quot;Row indices out of range&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">cols</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">colsList</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s">&quot;Column indices out of range&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rowsList</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">colsList</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">:</span> <span class="n">mat</span><span class="p">[</span><span class="n">rowsList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">cols</span> <span class="o">+</span> <span class="n">colsList</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span>
</div>
<div class="viewcode-block" id="Matrix.slice2bounds"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.slice2bounds">[docs]</a>    <span class="k">def</span> <span class="nf">slice2bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">defmax</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Takes slice or number and returns (min,max) for iteration</span>
<span class="sd">            Takes a default maxval to deal with the slice &#39;:&#39; which is (none, none)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">defmax</span>
            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">lo</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">start</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">lo</span> <span class="o">=</span> <span class="n">defmax</span><span class="o">+</span><span class="n">key</span><span class="o">.</span><span class="n">start</span>
            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">hi</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">hi</span> <span class="o">=</span> <span class="n">defmax</span><span class="o">+</span><span class="n">key</span><span class="o">.</span><span class="n">stop</span>
            <span class="k">return</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">key</span><span class="p">,</span> <span class="n">key</span><span class="o">+</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">defmax</span><span class="o">+</span><span class="n">key</span><span class="p">,</span> <span class="n">defmax</span><span class="o">+</span><span class="n">key</span><span class="o">+</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s">&quot;Improper index type&quot;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Matrix.applyfunc"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.applyfunc">[docs]</a>    <span class="k">def</span> <span class="nf">applyfunc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(2,2,lambda i,j: i*2+j)</span>
<span class="sd">        &gt;&gt;&gt; m   #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        [0, 1]</span>
<span class="sd">        [2, 3]</span>
<span class="sd">        &gt;&gt;&gt; m.applyfunc(lambda i: 2*i)  #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        [0, 2]</span>
<span class="sd">        [4, 6]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;`f` must be callable.&quot;</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span><span class="nb">map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">out</span>
</div>
    <span class="k">def</span> <span class="nf">evalf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">prec</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">applyfunc</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">i</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="o">**</span><span class="n">options</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">applyfunc</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">i</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">prec</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">))</span>

<div class="viewcode-block" id="Matrix.reshape"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.reshape">[docs]</a>    <span class="k">def</span> <span class="nf">reshape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_rows</span><span class="p">,</span> <span class="n">_cols</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(2,3,lambda i,j: 1)</span>
<span class="sd">        &gt;&gt;&gt; m   #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        [1, 1, 1]</span>
<span class="sd">        [1, 1, 1]</span>
<span class="sd">        &gt;&gt;&gt; m.reshape(1,6)  #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        [1, 1, 1, 1, 1, 1]</span>
<span class="sd">        &gt;&gt;&gt; m.reshape(3,2)  #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        [1, 1]</span>
<span class="sd">        [1, 1]</span>
<span class="sd">        [1, 1]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="n">_rows</span><span class="o">*</span><span class="n">_cols</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Invalid reshape parameters </span><span class="si">%d</span><span class="s"> </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">_rows</span><span class="p">,</span> <span class="n">_cols</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">_rows</span><span class="p">,</span> <span class="n">_cols</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">_cols</span> <span class="o">+</span> <span class="n">j</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="Matrix.print_nonzero"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.print_nonzero">[docs]</a>    <span class="k">def</span> <span class="nf">print_nonzero</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symb</span><span class="o">=</span><span class="s">&quot;X&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shows location of non-zero entries for fast shape lookup ::</span>

<span class="sd">            &gt;&gt;&gt; from sympy import Matrix, matrices</span>
<span class="sd">            &gt;&gt;&gt; m = Matrix(2,3,lambda i,j: i*3+j)</span>
<span class="sd">            &gt;&gt;&gt; m           #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            [0, 1, 2]</span>
<span class="sd">            [3, 4, 5]</span>
<span class="sd">            &gt;&gt;&gt; m.print_nonzero()   #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            [ XX]</span>
<span class="sd">            [XXX]</span>
<span class="sd">            &gt;&gt;&gt; m = matrices.eye(4)</span>
<span class="sd">            &gt;&gt;&gt; m.print_nonzero(&quot;x&quot;)    #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            [x   ]</span>
<span class="sd">            [ x  ]</span>
<span class="sd">            [  x ]</span>
<span class="sd">            [   x]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;[&quot;</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot; &quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">s</span> <span class="o">+=</span> <span class="n">symb</span> <span class="o">+</span> <span class="s">&quot;&quot;</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span>
        <span class="k">print</span> <span class="n">s</span>
</div>
<div class="viewcode-block" id="Matrix.LUsolve"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.LUsolve">[docs]</a>    <span class="k">def</span> <span class="nf">LUsolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">iszerofunc</span><span class="o">=</span><span class="n">_iszero</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solve the linear system Ax = b for x.</span>
<span class="sd">        self is the coefficient matrix A and rhs is the right side b.</span>

<span class="sd">        This is for symbolic matrices, for real or complex ones use</span>
<span class="sd">        sympy.mpmath.lu_solve or sympy.mpmath.qr_solve.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">rhs</span><span class="o">.</span><span class="n">rows</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ShapeError</span><span class="p">(</span><span class="s">&quot;`self` and `rhs` must have the same number of rows.&quot;</span><span class="p">)</span>

        <span class="n">A</span><span class="p">,</span> <span class="n">perm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LUdecomposition_Simple</span><span class="p">(</span><span class="n">iszerofunc</span><span class="o">=</span><span class="n">_iszero</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">permuteFwd</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>
        <span class="c"># forward substitution, all diag entries are scaled to 1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="n">b</span><span class="o">.</span><span class="n">row</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">k</span><span class="p">:</span> <span class="n">x</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span>
        <span class="c"># backward substitution</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="n">b</span><span class="o">.</span><span class="n">row</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">k</span><span class="p">:</span> <span class="n">x</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span>
            <span class="n">b</span><span class="o">.</span><span class="n">row</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">k</span><span class="p">:</span> <span class="n">x</span> <span class="o">/</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">b</span>
</div>
<div class="viewcode-block" id="Matrix.LUdecomposition"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.LUdecomposition">[docs]</a>    <span class="k">def</span> <span class="nf">LUdecomposition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iszerofunc</span><span class="o">=</span><span class="n">_iszero</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the decomposition LU and the row swaps p.</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; a = Matrix([[4, 3], [6, 3]])</span>
<span class="sd">        &gt;&gt;&gt; L, U, _ = a.LUdecomposition()</span>
<span class="sd">        &gt;&gt;&gt; L</span>
<span class="sd">        [  1, 0]</span>
<span class="sd">        [3/2, 1]</span>
<span class="sd">        &gt;&gt;&gt; U</span>
<span class="sd">        [4,    3]</span>
<span class="sd">        [0, -3/2]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">combined</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LUdecomposition_Simple</span><span class="p">(</span><span class="n">iszerofunc</span><span class="o">=</span><span class="n">_iszero</span><span class="p">)</span>
        <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">)</span>
        <span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">combined</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                        <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">U</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">combined</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">L</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">p</span>
</div>
<div class="viewcode-block" id="Matrix.LUdecomposition_Simple"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.LUdecomposition_Simple">[docs]</a>    <span class="k">def</span> <span class="nf">LUdecomposition_Simple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iszerofunc</span><span class="o">=</span><span class="n">_iszero</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns A comprised of L,U (L&#39;s diag entries are 1) and</span>
<span class="sd">        p which is the list of the row swaps (in order).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">()</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[:,:]</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c"># factorization</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                    <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
            <span class="n">pivot</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
                    <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
                <span class="c"># find the first non-zero pivot, includes any expression</span>
                <span class="k">if</span> <span class="n">pivot</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">iszerofunc</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]):</span>
                    <span class="n">pivot</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">if</span> <span class="n">pivot</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c"># this result is based on iszerofunc&#39;s analysis of the possible pivots, so even though</span>
                <span class="c"># the element may not be strictly zero, the supplied iszerofunc&#39;s evaluation gave True</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;No nonzero pivot found; inversion failed.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pivot</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span> <span class="c"># row must be swapped</span>
                <span class="n">A</span><span class="o">.</span><span class="n">row_swap</span><span class="p">(</span><span class="n">pivot</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
                <span class="n">p</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">pivot</span><span class="p">,</span><span class="n">j</span><span class="p">])</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
                <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale</span>
        <span class="k">return</span> <span class="n">A</span><span class="p">,</span> <span class="n">p</span>

</div>
<div class="viewcode-block" id="Matrix.LUdecompositionFF"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.LUdecompositionFF">[docs]</a>    <span class="k">def</span> <span class="nf">LUdecompositionFF</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a fraction-free LU decomposition.</span>

<span class="sd">        Returns 4 matrices P, L, D, U such that PA = L D**-1 U.</span>
<span class="sd">        If the elements of the matrix belong to some integral domain I, then all</span>
<span class="sd">        elements of L, D and U are guaranteed to belong to I.</span>

<span class="sd">        **Reference**</span>
<span class="sd">            - W. Zhou &amp; D.J. Jeffrey, &quot;Fraction-free matrix factors: new forms</span>
<span class="sd">              for LU and QR factors&quot;. Frontiers in Computer Science in China,</span>
<span class="sd">              Vol 2, no. 1, pp. 67-80, 2008.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span>
        <span class="n">U</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[:,:],</span> <span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">DD</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="c"># store it smarter since it&#39;s just diagonal</span>
        <span class="n">oldpivot</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">U</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">kpivot</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">U</span><span class="p">[</span><span class="n">kpivot</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Matrix is not full rank&quot;</span><span class="p">)</span>
                <span class="n">U</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">:],</span> <span class="n">U</span><span class="p">[</span><span class="n">kpivot</span><span class="p">,</span> <span class="n">k</span><span class="p">:]</span> <span class="o">=</span> <span class="n">U</span><span class="p">[</span><span class="n">kpivot</span><span class="p">,</span> <span class="n">k</span><span class="p">:],</span> <span class="n">U</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">:]</span>
                <span class="n">L</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:</span><span class="n">k</span><span class="p">],</span> <span class="n">L</span><span class="p">[</span><span class="n">kpivot</span><span class="p">,</span> <span class="p">:</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">kpivot</span><span class="p">,</span> <span class="p">:</span><span class="n">k</span><span class="p">],</span> <span class="n">L</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:</span><span class="n">k</span><span class="p">]</span>
                <span class="n">P</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:],</span> <span class="n">P</span><span class="p">[</span><span class="n">kpivot</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">kpivot</span><span class="p">,</span> <span class="p">:],</span> <span class="n">P</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">L</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ukk</span> <span class="o">=</span> <span class="n">U</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">k</span><span class="p">]</span>
            <span class="n">DD</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldpivot</span> <span class="o">*</span> <span class="n">Ukk</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">Uik</span> <span class="o">=</span> <span class="n">U</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
                    <span class="n">U</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ukk</span> <span class="o">*</span> <span class="n">U</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">U</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">Uik</span><span class="p">)</span> <span class="o">/</span> <span class="n">oldpivot</span>
                <span class="n">U</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">oldpivot</span> <span class="o">=</span> <span class="n">Ukk</span>
        <span class="n">DD</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldpivot</span>
        <span class="k">return</span> <span class="n">P</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">DD</span><span class="p">,</span> <span class="n">U</span>
</div>
    <span class="k">def</span> <span class="nf">cofactorMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&quot;berkowitz&quot;</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cofactor</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">method</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">minorEntry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&quot;berkowitz&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="ow">or</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;`i` and `j` must satisfy 0 &lt;= i &lt; `self.rows` &quot;</span> <span class="o">+</span>
                <span class="s">&quot;(</span><span class="si">%d</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">+</span> <span class="s">&quot;and 0 &lt;= j &lt; `self.cols` (</span><span class="si">%d</span><span class="s">).&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">minorMatrix</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">minorMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="ow">or</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;`i` and `j` must satisfy 0 &lt;= i &lt; `self.rows` &quot;</span> <span class="o">+</span>
                <span class="s">&quot;(</span><span class="si">%d</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">+</span> <span class="s">&quot;and 0 &lt;= j &lt; `self.cols` (</span><span class="si">%d</span><span class="s">).&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">delRowCol</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cofactor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&quot;berkowitz&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">minorEntry</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">minorEntry</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>

<div class="viewcode-block" id="Matrix.jacobian"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.jacobian">[docs]</a>    <span class="k">def</span> <span class="nf">jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the Jacobian matrix (derivative of a vectorial function).</span>

<span class="sd">        *self*</span>
<span class="sd">            A vector of expressions representing functions f_i(x_1, ..., x_n).</span>
<span class="sd">        *X*</span>
<span class="sd">            The set of x_i&#39;s in order, it can be a list or a Matrix</span>

<span class="sd">        Both self and X can be a row or a column matrix in any order</span>
<span class="sd">        (jacobian() should always work).</span>

<span class="sd">        Examples::</span>

<span class="sd">            &gt;&gt;&gt; from sympy import sin, cos, Matrix</span>
<span class="sd">            &gt;&gt;&gt; from sympy.abc import rho, phi</span>
<span class="sd">            &gt;&gt;&gt; X = Matrix([rho*cos(phi), rho*sin(phi), rho**2])</span>
<span class="sd">            &gt;&gt;&gt; Y = Matrix([rho, phi])</span>
<span class="sd">            &gt;&gt;&gt; X.jacobian(Y)</span>
<span class="sd">            [cos(phi), -rho*sin(phi)]</span>
<span class="sd">            [sin(phi),  rho*cos(phi)]</span>
<span class="sd">            [   2*rho,             0]</span>
<span class="sd">            &gt;&gt;&gt; X = Matrix([rho*cos(phi), rho*sin(phi)])</span>
<span class="sd">            &gt;&gt;&gt; X.jacobian(Y)</span>
<span class="sd">            [cos(phi), -rho*sin(phi)]</span>
<span class="sd">            [sin(phi),  rho*cos(phi)]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">):</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="c"># Both X and self can be a row or a column matrix, so we need to make</span>
        <span class="c"># sure all valid combinations work, but everything else fails:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;self must be a row or a column matrix&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;X must be a row or a column matrix&quot;</span><span class="p">)</span>

        <span class="c"># m is the number of functions and n is the number of variables</span>
        <span class="c"># computing the Jacobian is now easy:</span>
        <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="bp">self</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
</div>
<div class="viewcode-block" id="Matrix.QRdecomposition"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.QRdecomposition">[docs]</a>    <span class="k">def</span> <span class="nf">QRdecomposition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return Q,R where A = Q*R, Q is orthogonal and R is upper triangular.</span>

<span class="sd">        Examples</span>

<span class="sd">        This is the example from wikipedia::</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix, eye</span>
<span class="sd">        &gt;&gt;&gt; A = Matrix([[12,-51,4],[6,167,-68],[-4,24,-41]])</span>
<span class="sd">        &gt;&gt;&gt; Q, R = A.QRdecomposition()</span>
<span class="sd">        &gt;&gt;&gt; Q</span>
<span class="sd">        [ 6/7, -69/175, -58/175]</span>
<span class="sd">        [ 3/7, 158/175,   6/175]</span>
<span class="sd">        [-2/7,    6/35,  -33/35]</span>
<span class="sd">        &gt;&gt;&gt; R</span>
<span class="sd">        [14,  21, -14]</span>
<span class="sd">        [ 0, 175, -70]</span>
<span class="sd">        [ 0,   0,  35]</span>
<span class="sd">        &gt;&gt;&gt; A == Q*R</span>
<span class="sd">        True</span>

<span class="sd">        QR factorization of an identity matrix</span>
<span class="sd">        &gt;&gt;&gt; A = Matrix([[1,0,0],[0,1,0],[0,0,1]])</span>
<span class="sd">        &gt;&gt;&gt; Q, R = A.QRdecomposition()</span>
<span class="sd">        &gt;&gt;&gt; Q</span>
<span class="sd">        [1, 0, 0]</span>
<span class="sd">        [0, 1, 0]</span>
<span class="sd">        [0, 0, 1]</span>
<span class="sd">        &gt;&gt;&gt; R</span>
<span class="sd">        [1, 0, 0]</span>
<span class="sd">        [0, 1, 0]</span>
<span class="sd">        [0, 0, 1]</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MatrixError</span><span class="p">(</span><span class="s">&quot;The number of rows must be greater than columns&quot;</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="n">n</span>
        <span class="n">row_reduced</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rref</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">row_reduced</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">row_reduced</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">m</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">m</span><span class="p">])</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">rank</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">rank</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MatrixError</span><span class="p">(</span><span class="s">&quot;The rank of the matrix must match the columns&quot;</span><span class="p">)</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>      <span class="c"># for each column vector</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[:,</span><span class="n">j</span><span class="p">]</span>     <span class="c"># take original v</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
                <span class="c"># subtract the project of self on new vector</span>
                <span class="n">tmp</span> <span class="o">-=</span> <span class="n">Q</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="p">[:,</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Q</span><span class="p">[:,</span><span class="n">i</span><span class="p">])</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
            <span class="c"># normalize it</span>
            <span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
            <span class="n">Q</span><span class="p">[:,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">/</span> <span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">Q</span><span class="p">[:,</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Could not normalize the vector </span><span class="si">%d</span><span class="s">.&quot;</span> <span class="o">%</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
                <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">Q</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">[:,</span><span class="n">j</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">Q</span><span class="p">,</span><span class="n">R</span>
</div>
<div class="viewcode-block" id="Matrix.QRsolve"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.QRsolve">[docs]</a>    <span class="k">def</span> <span class="nf">QRsolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solve the linear system &#39;Ax = b&#39;.</span>

<span class="sd">        &#39;self&#39; is the matrix &#39;A&#39;, the method argument is the vector</span>
<span class="sd">        &#39;b&#39;.  The method returns the solution vector &#39;x&#39;.  If &#39;b&#39; is a</span>
<span class="sd">        matrix, the system is solved for each column of &#39;b&#39; and the</span>
<span class="sd">        return value is a matrix of the same shape as &#39;b&#39;.</span>

<span class="sd">        This method is slower (approximately by a factor of 2) but</span>
<span class="sd">        more stable for floating-point arithmetic than the LUsolve method.</span>
<span class="sd">        However, LUsolve usually uses an exact arithmetic, so you don&#39;t need</span>
<span class="sd">        to use QRsolve.</span>

<span class="sd">        This is mainly for educational purposes and symbolic matrices, for real</span>
<span class="sd">        (or complex) matrices use sympy.mpmath.qr_solve.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">Q</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">QRdecomposition</span><span class="p">()</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">b</span>

        <span class="c"># back substitution to solve R*x = y:</span>
        <span class="c"># We build up the result &quot;backwards&quot; in the vector &#39;x&#39; and reverse it</span>
        <span class="c"># only in the end.</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">rows</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">,:]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="n">tmp</span> <span class="o">-=</span> <span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">k</span><span class="p">]</span>
            <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp</span><span class="o">/</span><span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">j</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">Matrix</span><span class="p">([</span><span class="n">row</span><span class="o">.</span><span class="n">mat</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">x</span><span class="p">)])</span>

    <span class="c"># Utility functions</span></div>
<div class="viewcode-block" id="Matrix.simplify"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.simplify">[docs]</a>    <span class="k">def</span> <span class="nf">simplify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="n">sympy_simplify</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="mf">1.7</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Simplify the elements of a matrix in place.</span>

<span class="sd">        If (result length)/(input length) &gt; ratio, then input is returned</span>
<span class="sd">        unmodified. If &#39;ratio=oo&#39;, then simplify() is applied anyway.</span>

<span class="sd">        See also simplify().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ratio</span><span class="o">=</span><span class="n">ratio</span><span class="p">)</span>

    <span class="c">#def evaluate(self):    # no more eval() so should be removed</span>
    <span class="c">#    for i in range(self.rows):</span>
    <span class="c">#        for j in range(self.cols):</span>
    <span class="c">#            self[i,j] = self[i,j].eval()</span>
</div>
    <span class="k">def</span> <span class="nf">cross</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="n">Matrix</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;`b` must be an ordered iterable or Matrix, not </span><span class="si">%s</span><span class="s">.&quot;</span> <span class="o">%</span>
                <span class="nb">type</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">or</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">)</span> <span class="ow">and</span> \
                <span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">rows</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">cols</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">or</span> \
                <span class="n">b</span><span class="o">.</span><span class="n">rows</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">cols</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ShapeError</span><span class="p">(</span><span class="s">&quot;Dimensions incorrect for cross product.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,((</span><span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                               <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
                               <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>

    <span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="n">Matrix</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;`b` must be an ordered iterable or Matrix, not </span><span class="si">%s</span><span class="s">.&quot;</span> <span class="o">%</span>
                <span class="nb">type</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="n">m</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ShapeError</span><span class="p">(</span><span class="s">&quot;Dimensions incorrect for dot product.&quot;</span><span class="p">)</span>
        <span class="n">prod</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="n">prod</span> <span class="o">+=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">prod</span>

<div class="viewcode-block" id="Matrix.multiply_elementwise"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.multiply_elementwise">[docs]</a>    <span class="k">def</span> <span class="nf">multiply_elementwise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the Hadamard product (elementwise product) of A and B</span>

<span class="sd">        &gt;&gt;&gt; import sympy</span>
<span class="sd">        &gt;&gt;&gt; A = sympy.Matrix([[0, 1, 2], [3, 4, 5]])</span>
<span class="sd">        &gt;&gt;&gt; B = sympy.Matrix([[1, 10, 100], [100, 10, 1]])</span>
<span class="sd">        &gt;&gt;&gt; print A.multiply_elementwise(B)</span>
<span class="sd">        [  0, 10, 200]</span>
<span class="sd">        [300, 40,   5]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">matrix_multiply_elementwise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Matrix.norm"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.norm">[docs]</a>    <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the Norm of a Matrix or Vector.</span>
<span class="sd">        In the simplest case this is the geometric size of the vector</span>
<span class="sd">        Other norms can be specified by the ord parameter</span>


<span class="sd">        =====  ============================  ==========================</span>
<span class="sd">        ord    norm for matrices             norm for vectors</span>
<span class="sd">        =====  ============================  ==========================</span>
<span class="sd">        None   Frobenius norm                2-norm</span>
<span class="sd">        &#39;fro&#39;  Frobenius norm                - does not exist</span>
<span class="sd">        inf    --                            max(abs(x))</span>
<span class="sd">        -inf   --                            min(abs(x))</span>
<span class="sd">        1      --                            as below</span>
<span class="sd">        -1     --                            as below</span>
<span class="sd">        2      2-norm (largest sing. value)  as below</span>
<span class="sd">        -2     smallest singular value       as below</span>
<span class="sd">        other  - does not exist              sum(abs(x)**ord)**(1./ord)</span>
<span class="sd">        =====  ============================  ==========================</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix, var, trigsimp, cos, sin</span>
<span class="sd">        &gt;&gt;&gt; x = var(&#39;x&#39;, real=True)</span>
<span class="sd">        &gt;&gt;&gt; v = Matrix([cos(x), sin(x)])</span>
<span class="sd">        &gt;&gt;&gt; print trigsimp( v.norm() )</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; print v.norm(10)</span>
<span class="sd">        (sin(x)**10 + cos(x)**10)**(1/10)</span>
<span class="sd">        &gt;&gt;&gt; A = Matrix([[1,1], [1,1]])</span>
<span class="sd">        &gt;&gt;&gt; print A.norm(2)# Spectral norm (max of |Ax|/|x| under 2-vector-norm)</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; print A.norm(-2) # Inverse spectral norm (smallest singular value)</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; print A.norm() # Frobenius Norm</span>
<span class="sd">        2</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># Row or Column Vector Norms</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">ord</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span> <span class="nb">ord</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span> <span class="c"># Common case sqrt(&lt;x,x&gt;)</span>
                <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">))</span><span class="o">**</span><span class="n">S</span><span class="o">.</span><span class="n">Half</span>

            <span class="k">elif</span> <span class="nb">ord</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c"># sum(abs(x))</span>
                <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">))</span>

            <span class="k">elif</span> <span class="nb">ord</span> <span class="o">==</span> <span class="n">S</span><span class="o">.</span><span class="n">Infinity</span><span class="p">:</span> <span class="c"># max(abs(x))</span>
                <span class="k">return</span> <span class="n">Max</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">applyfunc</span><span class="p">(</span><span class="nb">abs</span><span class="p">))</span>

            <span class="k">elif</span> <span class="nb">ord</span> <span class="o">==</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeInfinity</span><span class="p">:</span> <span class="c"># min(abs(x))</span>
                <span class="k">return</span> <span class="n">Min</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">applyfunc</span><span class="p">(</span><span class="nb">abs</span><span class="p">))</span>

            <span class="c"># Otherwise generalize the 2-norm, Sum(x_i**ord)**(1/ord)</span>
            <span class="c"># Note that while useful this is not mathematically a norm</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Pow</span><span class="p">(</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">**</span><span class="nb">ord</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">)),</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="nb">ord</span> <span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Expected order to be Number, Symbol, oo&quot;</span><span class="p">)</span>

        <span class="c"># Matrix Norms</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">ord</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="c"># Spectral Norm</span>
                <span class="c"># Maximum singular value</span>
                <span class="k">return</span> <span class="n">Max</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">singular_values</span><span class="p">())</span>

            <span class="k">elif</span> <span class="nb">ord</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                <span class="c"># Minimum singular value</span>
                <span class="k">return</span> <span class="n">Min</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">singular_values</span><span class="p">())</span>

            <span class="k">elif</span> <span class="p">(</span><span class="nb">ord</span> <span class="o">==</span> <span class="bp">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">ord</span><span class="p">,</span><span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">ord</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span>
                    <span class="p">[</span><span class="s">&#39;f&#39;</span><span class="p">,</span> <span class="s">&#39;fro&#39;</span><span class="p">,</span> <span class="s">&#39;frobenius&#39;</span><span class="p">,</span> <span class="s">&#39;vector&#39;</span><span class="p">]):</span>
                <span class="c"># Reshape as vector and send back to norm function</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vec</span><span class="p">()</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Matrix Norms under development&quot;</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">normalized</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ShapeError</span><span class="p">(</span><span class="s">&quot;A Matrix must be a vector to normalize.&quot;</span><span class="p">)</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">applyfunc</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">i</span> <span class="o">/</span> <span class="n">norm</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

<div class="viewcode-block" id="Matrix.project"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.project">[docs]</a>    <span class="k">def</span> <span class="nf">project</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Project onto v.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">v</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">/</span> <span class="n">v</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
</div>
    <span class="k">def</span> <span class="nf">permuteBkwd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">perm</span><span class="p">):</span>
        <span class="n">copy</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[:,:]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">copy</span><span class="o">.</span><span class="n">row_swap</span><span class="p">(</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">copy</span>

    <span class="k">def</span> <span class="nf">permuteFwd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">perm</span><span class="p">):</span>
        <span class="n">copy</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[:,:]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">perm</span><span class="p">)):</span>
            <span class="n">copy</span><span class="o">.</span><span class="n">row_swap</span><span class="p">(</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">copy</span>

    <span class="k">def</span> <span class="nf">delRowCol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="c"># used only for cofactors, makes a copy</span>
        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[:,:]</span>
        <span class="n">M</span><span class="o">.</span><span class="n">row_del</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">M</span><span class="o">.</span><span class="n">col_del</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">M</span>

<div class="viewcode-block" id="Matrix.exp"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.exp">[docs]</a>    <span class="k">def</span> <span class="nf">exp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the exponent of a matrix &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">(</span><span class="s">&quot;Exponentiation is valid only for square matrices&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">U</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diagonalize</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">MatrixError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Exponentiation is implemented only for diagonalizable matrices&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">D</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
            <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">U</span> <span class="o">*</span> <span class="n">D</span> <span class="o">*</span> <span class="n">U</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Matrix.zeros"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.zeros">[docs]</a>    <span class="k">def</span> <span class="nf">zeros</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dims</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a dims = (d1,d2) matrix of zeros.&quot;&quot;&quot;</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">_dims_to_nm</span><span class="p">(</span> <span class="n">dims</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">,[</span><span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="o">*</span><span class="n">m</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Matrix.eye"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.eye">[docs]</a>    <span class="k">def</span> <span class="nf">eye</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the identity matrix of size n.&quot;&quot;&quot;</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
            <span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
        <span class="k">return</span> <span class="n">tmp</span>
</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_square</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span>

<div class="viewcode-block" id="Matrix.is_nilpotent"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.is_nilpotent">[docs]</a>    <span class="k">def</span> <span class="nf">is_nilpotent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if a matrix is nilpotent.</span>

<span class="sd">        A matrix B is nilpotent if for some integer k, B**k is</span>
<span class="sd">        a zero matrix.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">            &gt;&gt;&gt; a = Matrix([[0,0,0],[1,0,0],[1,1,0]])</span>
<span class="sd">            &gt;&gt;&gt; a.is_nilpotent()</span>
<span class="sd">            True</span>

<span class="sd">            &gt;&gt;&gt; a = Matrix([[1,0,1],[1,0,0],[1,1,0]])</span>
<span class="sd">            &gt;&gt;&gt; a.is_nilpotent()</span>
<span class="sd">            False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">(</span><span class="s">&quot;Nilpotency is valid only for square matrices&quot;</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">charpoly</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="Matrix.is_upper"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.is_upper">[docs]</a>    <span class="k">def</span> <span class="nf">is_upper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if matrix is an upper triangular matrix.</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(2,2,[1, 0, 0, 1])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        [1, 0]</span>
<span class="sd">        [0, 1]</span>
<span class="sd">        &gt;&gt;&gt; m.is_upper()</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; m = Matrix(3,3,[5, 1, 9, 0, 4 , 6, 0, 0, 5])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        [5, 1, 9]</span>
<span class="sd">        [0, 4, 6]</span>
<span class="sd">        [0, 0, 5]</span>
<span class="sd">        &gt;&gt;&gt; m.is_upper()</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; m = Matrix(2,3,[4, 2, 5, 6, 1, 1])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        [4, 2, 5]</span>
<span class="sd">        [6, 1, 1]</span>
<span class="sd">        &gt;&gt;&gt; m.is_upper()</span>
<span class="sd">        False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="Matrix.is_lower"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.is_lower">[docs]</a>    <span class="k">def</span> <span class="nf">is_lower</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if matrix is a lower triangular matrix.</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(2,2,[1, 0, 0, 1])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        [1, 0]</span>
<span class="sd">        [0, 1]</span>
<span class="sd">        &gt;&gt;&gt; m.is_lower()</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; m = Matrix(3,3,[2, 0, 0, 1, 4 , 0, 6, 6, 5])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        [2, 0, 0]</span>
<span class="sd">        [1, 4, 0]</span>
<span class="sd">        [6, 6, 5]</span>
<span class="sd">        &gt;&gt;&gt; m.is_lower()</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(2,2,[x**2 + y, y**2 + x, 0, x + y])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        [x**2 + y, x + y**2]</span>
<span class="sd">        [       0,    x + y]</span>
<span class="sd">        &gt;&gt;&gt; m.is_lower()</span>
<span class="sd">        False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="Matrix.is_upper_hessenberg"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.is_upper_hessenberg">[docs]</a>    <span class="k">def</span> <span class="nf">is_upper_hessenberg</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the matrix is the upper hessenberg form.</span>

<span class="sd">        The upper hessenberg matrix has zero entries</span>
<span class="sd">        below the first subdiagonal.</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; from sympy.matrices import Matrix</span>
<span class="sd">        &gt;&gt;&gt; a = Matrix([[1,4,2,3],[3,4,1,7],[0,2,3,4],[0,0,1,3]])</span>
<span class="sd">        &gt;&gt;&gt; a</span>
<span class="sd">        [1, 4, 2, 3]</span>
<span class="sd">        [3, 4, 1, 7]</span>
<span class="sd">        [0, 2, 3, 4]</span>
<span class="sd">        [0, 0, 1, 3]</span>
<span class="sd">        &gt;&gt;&gt; a.is_upper_hessenberg()</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="Matrix.is_lower_hessenberg"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.is_lower_hessenberg">[docs]</a>    <span class="k">def</span> <span class="nf">is_lower_hessenberg</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Checks if the matrix is in the lower hessenberg form.</span>

<span class="sd">        The lower hessenberg matrix has zero entries</span>
<span class="sd">        above the first superdiagonal.</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; from sympy.matrices import Matrix</span>
<span class="sd">        &gt;&gt;&gt; a = Matrix([[1,2,0,0],[5,2,3,0],[3,4,3,7],[5,6,1,1]])</span>
<span class="sd">        &gt;&gt;&gt; a</span>
<span class="sd">        [1, 2, 0, 0]</span>
<span class="sd">        [5, 2, 3, 0]</span>
<span class="sd">        [3, 4, 3, 7]</span>
<span class="sd">        [5, 6, 1, 1]</span>
<span class="sd">        &gt;&gt;&gt; a.is_lower_hessenberg()</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
    <span class="k">def</span> <span class="nf">is_symbolic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">element</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">Symbol</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>

<div class="viewcode-block" id="Matrix.is_symmetric"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.is_symmetric">[docs]</a>    <span class="k">def</span> <span class="nf">is_symmetric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if matrix is symmetric matrix,</span>
<span class="sd">        that is square matrix and is equal to its transpose.</span>

<span class="sd">        By default, simplifications occur before testing symmetry.</span>
<span class="sd">        They can be skipped using &#39;simplify=False&#39;; while speeding things a bit,</span>
<span class="sd">        this may however induce false negatives.</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(2,2,[0, 1, 1, 2])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        [0, 1]</span>
<span class="sd">        [1, 2]</span>
<span class="sd">        &gt;&gt;&gt; m.is_symmetric()</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; m = Matrix(2,2,[0, 1, 2, 0])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        [0, 1]</span>
<span class="sd">        [2, 0]</span>
<span class="sd">        &gt;&gt;&gt; m.is_symmetric()</span>
<span class="sd">        False</span>

<span class="sd">        &gt;&gt;&gt; m = Matrix(2,3,[0, 0, 0, 0, 0, 0])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        [0, 0, 0]</span>
<span class="sd">        [0, 0, 0]</span>
<span class="sd">        &gt;&gt;&gt; m.is_symmetric()</span>
<span class="sd">        False</span>

<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(3,3,[1, x**2 + 2*x + 1, y, (x + 1)**2 , 2, 0, y, 0, 3])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        [         1, x**2 + 2*x + 1, y]</span>
<span class="sd">        [(x + 1)**2,              2, 0]</span>
<span class="sd">        [         y,              0, 3]</span>
<span class="sd">        &gt;&gt;&gt; m.is_symmetric()</span>
<span class="sd">        True</span>

<span class="sd">        If the matrix is already simplified, you may speed-up is_symmetric()</span>
<span class="sd">        test by using &#39;simplify=False&#39;.</span>

<span class="sd">        &gt;&gt;&gt; m.is_symmetric(simplify=False)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; m1 = m.expand()</span>
<span class="sd">        &gt;&gt;&gt; m1.is_symmetric(simplify=False)</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">simplify</span><span class="p">:</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
            <span class="n">delta</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">delta</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Matrix.is_diagonal"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.is_diagonal">[docs]</a>    <span class="k">def</span> <span class="nf">is_diagonal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if matrix is diagonal,</span>
<span class="sd">        that is matrix in which the entries outside the main diagonal are all zero.</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix, diag</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(2,2,[1, 0, 0, 2])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        [1, 0]</span>
<span class="sd">        [0, 2]</span>
<span class="sd">        &gt;&gt;&gt; m.is_diagonal()</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; m = Matrix(2,2,[1, 1, 0, 2])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        [1, 1]</span>
<span class="sd">        [0, 2]</span>
<span class="sd">        &gt;&gt;&gt; m.is_diagonal()</span>
<span class="sd">        False</span>

<span class="sd">        &gt;&gt;&gt; m = diag(1, 2, 3)</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        [1, 0, 0]</span>
<span class="sd">        [0, 2, 0]</span>
<span class="sd">        [0, 0, 3]</span>
<span class="sd">        &gt;&gt;&gt; m.is_diagonal()</span>
<span class="sd">        True</span>

<span class="sd">        See also: .is_lower(), is_upper() .is_diagonalizable()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>

<div class="viewcode-block" id="Matrix.det"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.det">[docs]</a>    <span class="k">def</span> <span class="nf">det</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&quot;bareis&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the matrix determinant using the method &quot;method&quot;.</span>

<span class="sd">        Possible values for &quot;method&quot;:</span>
<span class="sd">          bareis ... det_bareis</span>
<span class="sd">          berkowitz ... berkowitz_det</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&quot;bareis&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">det_bareis</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&quot;berkowitz&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">berkowitz_det</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Determinant method unrecognized&quot;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Matrix.det_bareis"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.det_bareis">[docs]</a>    <span class="k">def</span> <span class="nf">det_bareis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute matrix determinant using Bareis&#39; fraction-free</span>
<span class="sd">           algorithm which is an extension of the well known Gaussian</span>
<span class="sd">           elimination method. This approach is best suited for dense</span>
<span class="sd">           symbolic matrices and will result in a determinant with</span>
<span class="sd">           minimal number of fractions. It means that less term</span>
<span class="sd">           rewriting is needed on resulting formulae.</span>

<span class="sd">           TODO: Implement algorithm for sparse matrices (SFF).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">()</span>

        <span class="n">M</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[:,:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">det</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">det</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span> <span class="c"># track current sign in case of column swap</span>

            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="c"># look for a pivot in the current column</span>
                <span class="c"># and assume det == 0 if none is found</span>
                <span class="k">if</span> <span class="n">M</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">M</span><span class="o">.</span><span class="n">row_swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                            <span class="n">sign</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
                            <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

                <span class="c"># proceed with Bareis&#39; fraction-free (FF)</span>
                <span class="c"># form of Gaussian elimination algorithm</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                        <span class="n">D</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">M</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

                        <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">D</span> <span class="o">/=</span> <span class="n">M</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                        <span class="k">if</span> <span class="n">D</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
                            <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">D</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">cancel</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>

            <span class="n">det</span> <span class="o">=</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">M</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">det</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Matrix.adjugate"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.adjugate">[docs]</a>    <span class="k">def</span> <span class="nf">adjugate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&quot;berkowitz&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the adjugate matrix.</span>

<span class="sd">        Adjugate matrix is the transpose of the cofactor matrix.</span>

<span class="sd">        http://en.wikipedia.org/wiki/Adjugate</span>

<span class="sd">        See also: .cofactorMatrix(), .T</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cofactorMatrix</span><span class="p">(</span><span class="n">method</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

</div>
<div class="viewcode-block" id="Matrix.inverse_LU"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.inverse_LU">[docs]</a>    <span class="k">def</span> <span class="nf">inverse_LU</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iszerofunc</span><span class="o">=</span><span class="n">_iszero</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the inverse using LU decomposition.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">LUsolve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">),</span> <span class="n">iszerofunc</span><span class="o">=</span><span class="n">_iszero</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Matrix.inverse_GE"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.inverse_GE">[docs]</a>    <span class="k">def</span> <span class="nf">inverse_GE</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iszerofunc</span><span class="o">=</span><span class="n">_iszero</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the inverse using Gaussian elimination.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">det</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;A Matrix must have non-zero determinant to invert.&quot;</span><span class="p">)</span>

        <span class="n">big</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">row_join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">))</span>
        <span class="n">red</span> <span class="o">=</span> <span class="n">big</span><span class="o">.</span><span class="n">rref</span><span class="p">(</span><span class="n">iszerofunc</span><span class="o">=</span><span class="n">iszerofunc</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">red</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span><span class="n">big</span><span class="o">.</span><span class="n">rows</span><span class="p">:]</span>
</div>
<div class="viewcode-block" id="Matrix.inverse_ADJ"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.inverse_ADJ">[docs]</a>    <span class="k">def</span> <span class="nf">inverse_ADJ</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the inverse using the adjugate matrix and a determinant.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">()</span>

        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">berkowitz_det</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;A Matrix must have non-zero determinant to invert.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjugate</span><span class="p">()</span><span class="o">/</span><span class="n">d</span>
</div>
<div class="viewcode-block" id="Matrix.rref"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.rref">[docs]</a>    <span class="k">def</span> <span class="nf">rref</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">simplified</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">iszerofunc</span><span class="o">=</span><span class="n">_iszero</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="n">sympy_simplify</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Take any matrix and return reduced row-echelon form and indices of pivot vars</span>

<span class="sd">        To simplify elements before finding nonzero pivots set simplified=True.</span>
<span class="sd">        To set a custom simplify function, use the simplify keyword argument.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># TODO: rewrite inverse_GE to use this</span>
        <span class="n">pivots</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="p">[:,:]</span>        <span class="c"># pivot: index of next row to contain a pivot</span>
        <span class="n">pivotlist</span> <span class="o">=</span> <span class="p">[]</span>                  <span class="c"># indices of pivot variables (non-free)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">pivots</span> <span class="o">==</span> <span class="n">r</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">simplified</span><span class="p">:</span>
                <span class="n">r</span><span class="p">[</span><span class="n">pivots</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">pivots</span><span class="p">,</span><span class="n">i</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">iszerofunc</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">pivots</span><span class="p">,</span><span class="n">i</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pivots</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">simplified</span> <span class="ow">and</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">pivots</span><span class="p">:</span>
                        <span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">iszerofunc</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">]):</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">r</span><span class="o">.</span><span class="n">rows</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">iszerofunc</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">]):</span>
                    <span class="k">continue</span>
                <span class="n">r</span><span class="o">.</span><span class="n">row_swap</span><span class="p">(</span><span class="n">pivots</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">pivots</span><span class="p">,</span><span class="n">i</span><span class="p">]</span>
            <span class="n">r</span><span class="o">.</span><span class="n">row</span><span class="p">(</span><span class="n">pivots</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">x</span><span class="o">/</span><span class="n">scale</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">pivots</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span>
                <span class="n">r</span><span class="o">.</span><span class="n">row</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">x</span> <span class="o">-</span> <span class="n">scale</span><span class="o">*</span><span class="n">r</span><span class="p">[</span><span class="n">pivots</span><span class="p">,</span><span class="n">k</span><span class="p">])</span>
            <span class="n">pivotlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">pivots</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">r</span><span class="p">,</span> <span class="n">pivotlist</span>
</div>
<div class="viewcode-block" id="Matrix.nullspace"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.nullspace">[docs]</a>    <span class="k">def</span> <span class="nf">nullspace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">simplified</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns list of vectors (Matrix objects) that span nullspace of self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reduced</span><span class="p">,</span> <span class="n">pivots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rref</span><span class="p">(</span><span class="n">simplified</span><span class="p">)</span>
        <span class="n">basis</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c"># create a set of vectors for the basis</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">pivots</span><span class="p">)):</span>
            <span class="n">basis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="c"># contains the variable index to which the vector corresponds</span>
        <span class="n">basiskey</span><span class="p">,</span> <span class="n">cur</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">basis</span><span class="p">),</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">pivots</span><span class="p">:</span>
                <span class="n">basiskey</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
                <span class="n">cur</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">pivots</span><span class="p">:</span> <span class="c"># free var, just set vector&#39;s ith place to 1</span>
                <span class="n">basis</span><span class="p">[</span><span class="n">basiskey</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">)][</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>               <span class="c"># add negative of nonpivot entry to corr vector</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
                    <span class="n">line</span> <span class="o">=</span> <span class="n">pivots</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">reduced</span><span class="p">[</span><span class="n">line</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">pivots</span><span class="p">:</span>
                            <span class="c"># XXX: Is this the correct error?</span>
                            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Could not compute the nullspace of `self`.&quot;</span><span class="p">)</span>
                        <span class="n">basis</span><span class="p">[</span><span class="n">basiskey</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">j</span><span class="p">)][</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">reduced</span><span class="p">[</span><span class="n">line</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">basis</span>
</div>
<div class="viewcode-block" id="Matrix.berkowitz"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.berkowitz">[docs]</a>    <span class="k">def</span> <span class="nf">berkowitz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The Berkowitz algorithm.</span>

<span class="sd">           Given N x N matrix with symbolic content, compute efficiently</span>
<span class="sd">           coefficients of characteristic polynomials of &#39;self&#39; and all</span>
<span class="sd">           its square sub-matrices composed by removing both i-th row</span>
<span class="sd">           and column, without division in the ground domain.</span>

<span class="sd">           This method is particularly useful for computing determinant,</span>
<span class="sd">           principal minors and characteristic polynomial, when &#39;self&#39;</span>
<span class="sd">           has complicated coefficients e.g. polynomials. Semi-direct</span>
<span class="sd">           usage of this algorithm is also important in computing</span>
<span class="sd">           efficiently sub-resultant PRS.</span>

<span class="sd">           Assuming that M is a square matrix of dimension N x N and</span>
<span class="sd">           I is N x N identity matrix,  then the following following</span>
<span class="sd">           definition of characteristic polynomial is begin used:</span>

<span class="sd">                          charpoly(M) = det(t*I - M)</span>

<span class="sd">           As a consequence, all polynomials generated by Berkowitz</span>
<span class="sd">           algorithm are monic.</span>

<span class="sd">           &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">           &gt;&gt;&gt; from sympy.abc import x, y, z</span>

<span class="sd">           &gt;&gt;&gt; M = Matrix([ [x,y,z], [1,0,0], [y,z,x] ])</span>

<span class="sd">           &gt;&gt;&gt; p, q, r = M.berkowitz()</span>

<span class="sd">           &gt;&gt;&gt; print p # 1 x 1 M&#39;s sub-matrix</span>
<span class="sd">           (1, -x)</span>

<span class="sd">           &gt;&gt;&gt; print q # 2 x 2 M&#39;s sub-matrix</span>
<span class="sd">           (1, -x, -y)</span>

<span class="sd">           &gt;&gt;&gt; print r # 3 x 3 M&#39;s sub-matrix</span>
<span class="sd">           (1, -2*x, x**2 - y*z - y, x*y - z**2)</span>

<span class="sd">           For more information on the implemented algorithm refer to:</span>

<span class="sd">           [1] S.J. Berkowitz, On computing the determinant in small</span>
<span class="sd">               parallel time using a small number of processors, ACM,</span>
<span class="sd">               Information Processing Letters 18, 1984, pp. 147-150</span>

<span class="sd">           [2] M. Keber, Division-Free computation of sub-resultants</span>
<span class="sd">               using Bezout matrices, Tech. Report MPI-I-2006-1-006,</span>
<span class="sd">               Saarbrucken, 2006</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">()</span>

        <span class="n">A</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span>
        <span class="n">transforms</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">T</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">)),</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="n">R</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="o">-</span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">,:</span><span class="n">k</span><span class="p">],</span> <span class="n">A</span><span class="p">[:</span><span class="n">k</span><span class="p">,</span><span class="n">k</span><span class="p">]</span>
            <span class="n">A</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:</span><span class="n">k</span><span class="p">,:</span><span class="n">k</span><span class="p">],</span> <span class="o">-</span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">k</span><span class="p">]</span>

            <span class="n">items</span> <span class="o">=</span> <span class="p">[</span> <span class="n">C</span> <span class="p">]</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">):</span>
                <span class="n">items</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span> <span class="o">*</span> <span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">B</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">items</span><span class="p">):</span>
                <span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span> <span class="o">*</span> <span class="n">B</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">items</span> <span class="o">=</span> <span class="p">[</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="n">a</span> <span class="p">]</span> <span class="o">+</span> <span class="n">items</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">items</span><span class="p">[:</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">transforms</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">T</span>

        <span class="n">polys</span> <span class="o">=</span> <span class="p">[</span> <span class="n">Matrix</span><span class="p">([</span><span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="o">-</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span> <span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">T</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">transforms</span><span class="p">):</span>
            <span class="n">polys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">T</span> <span class="o">*</span> <span class="n">polys</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">polys</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="Matrix.berkowitz_det"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.berkowitz_det">[docs]</a>    <span class="k">def</span> <span class="nf">berkowitz_det</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes determinant using Berkowitz method.&quot;&quot;&quot;</span>
        <span class="n">poly</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">berkowitz</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">poly</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="Matrix.berkowitz_minors"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.berkowitz_minors">[docs]</a>    <span class="k">def</span> <span class="nf">berkowitz_minors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes principal minors using Berkowitz method.&quot;&quot;&quot;</span>
        <span class="n">sign</span><span class="p">,</span> <span class="n">minors</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">,</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">berkowitz</span><span class="p">():</span>
            <span class="n">minors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sign</span><span class="o">*</span><span class="n">poly</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="n">sign</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">minors</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Matrix.berkowitz_charpoly"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.berkowitz_charpoly">[docs]</a>    <span class="k">def</span> <span class="nf">berkowitz_charpoly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="n">sympy_simplify</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes characteristic polynomial minors using Berkowitz method.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Poly</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">simplify</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">berkowitz</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">x</span><span class="p">)</span>
</div>
    <span class="n">charpoly</span> <span class="o">=</span> <span class="n">berkowitz_charpoly</span>

<div class="viewcode-block" id="Matrix.berkowitz_eigenvals"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.berkowitz_eigenvals">[docs]</a>    <span class="k">def</span> <span class="nf">berkowitz_eigenvals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes eigenvalues of a Matrix using Berkowitz method. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">roots</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">berkowitz_charpoly</span><span class="p">(</span><span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)),</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
</div>
    <span class="n">eigenvals</span> <span class="o">=</span> <span class="n">berkowitz_eigenvals</span>

<div class="viewcode-block" id="Matrix.eigenvects"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.eigenvects">[docs]</a>    <span class="k">def</span> <span class="nf">eigenvects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return list of triples (eigenval, multiplicity, basis).&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s">&#39;multiple&#39;</span> <span class="ow">in</span> <span class="n">flags</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">flags</span><span class="p">[</span><span class="s">&#39;multiple&#39;</span><span class="p">]</span>

        <span class="n">out</span><span class="p">,</span> <span class="n">vlist</span> <span class="o">=</span> <span class="p">[],</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvals</span><span class="p">(</span><span class="o">**</span><span class="n">flags</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">vlist</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">-</span> <span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">)</span><span class="o">*</span><span class="n">r</span>
            <span class="n">basis</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">nullspace</span><span class="p">()</span>
            <span class="c"># whether tmp.is_symbolic() is True or False, it is possible that</span>
            <span class="c"># the basis will come back as [] in which case simplification is</span>
            <span class="c"># necessary.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">basis</span><span class="p">:</span>
                <span class="c"># The nullspace routine failed, try it again with simplification</span>
                <span class="n">basis</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">nullspace</span><span class="p">(</span><span class="n">simplified</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">basis</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Can&#39;t evaluate eigenvector for eigenvalue </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">r</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">basis</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">out</span>
</div>
<div class="viewcode-block" id="Matrix.singular_values"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.singular_values">[docs]</a>    <span class="k">def</span> <span class="nf">singular_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the singular values of a Matrix</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix, Symbol, eye</span>
<span class="sd">        &gt;&gt;&gt; x = Symbol(&#39;x&#39;, real=True)</span>
<span class="sd">        &gt;&gt;&gt; A = Matrix([[0, 1, 0], [0, x, 0], [-1, 0, 0]])</span>
<span class="sd">        &gt;&gt;&gt; print A.singular_values()</span>
<span class="sd">        [1, (x**2 + 1)**(1/2), 0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Compute eigenvalues of A.H A</span>
        <span class="n">valmultpairs</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="o">*</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">eigenvals</span><span class="p">()</span>

        <span class="c"># Expands result from eigenvals into a simple list</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">valmultpairs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">vals</span> <span class="o">+=</span> <span class="p">[</span><span class="n">sqrt</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span><span class="o">*</span><span class="n">v</span> <span class="c"># dangerous! same k in several spots!</span>

        <span class="c"># If sorting makes sense then sort</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">is_number</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">):</span>
            <span class="n">vals</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c"># sort them in descending order</span>

        <span class="k">return</span> <span class="n">vals</span>
</div>
<div class="viewcode-block" id="Matrix.condition_number"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.condition_number">[docs]</a>    <span class="k">def</span> <span class="nf">condition_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the condition number of a matrix.</span>

<span class="sd">        This is the maximum singular value divided by the minimum singular value</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix, S</span>
<span class="sd">        &gt;&gt;&gt; A = Matrix([[1, 0, 0], [0, 10, 0], [0,0,S.One/10]])</span>
<span class="sd">        &gt;&gt;&gt; print A.condition_number()</span>
<span class="sd">        100</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">singularvalues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">singular_values</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">Max</span><span class="p">(</span><span class="o">*</span><span class="n">singularvalues</span><span class="p">)</span> <span class="o">/</span> <span class="n">Min</span><span class="p">(</span><span class="o">*</span><span class="n">singularvalues</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Matrix.fill"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.fill">[docs]</a>    <span class="k">def</span> <span class="nf">fill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fill the matrix with the scalar value.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mat</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;diff&#39;</span><span class="p">,</span><span class="s">&#39;integrate&#39;</span><span class="p">,</span><span class="s">&#39;limit&#39;</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">doit</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
                <span class="n">item_doit</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">attr</span><span class="p">)(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">applyfunc</span><span class="p">(</span> <span class="n">item_doit</span> <span class="p">)</span>
            <span class="k">return</span> <span class="n">doit</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s">&quot;Matrix has no attribute </span><span class="si">%s</span><span class="s">.&quot;</span> <span class="o">%</span> <span class="n">attr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">integrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">limit</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>

<div class="viewcode-block" id="Matrix.vec"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.vec">[docs]</a>    <span class="k">def</span> <span class="nf">vec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the Matrix converted into a one column matrix by stacking columns</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; m=Matrix([ [1,3], [2,4] ])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        [1, 3]</span>
<span class="sd">        [2, 4]</span>
<span class="sd">        &gt;&gt;&gt; m.vec()</span>
<span class="sd">        [1]</span>
<span class="sd">        [2]</span>
<span class="sd">        [3]</span>
<span class="sd">        [4]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">mat</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Matrix.vech"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.vech">[docs]</a>    <span class="k">def</span> <span class="nf">vech</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">diagonal</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">check_symmetry</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the unique elements of a symmetric Matrix as a one column matrix</span>
<span class="sd">        by stacking the elements in the lower triangle.</span>

<span class="sd">        Arguments:</span>
<span class="sd">        diagonal -- include the diagonal cells of self or not</span>
<span class="sd">        check_symmetry -- checks symmetry of self but not completely reliably</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; m=Matrix([ [1,2], [2,3] ])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        [1, 2]</span>
<span class="sd">        [2, 3]</span>
<span class="sd">        &gt;&gt;&gt; m.vech()</span>
<span class="sd">        [1]</span>
<span class="sd">        [2]</span>
<span class="sd">        [3]</span>
<span class="sd">        &gt;&gt;&gt; m.vech(diagonal=False)</span>
<span class="sd">        [2]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span>
        <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ShapeError</span><span class="p">(</span><span class="s">&quot;Matrix must be square&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">check_symmetry</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Matrix appears to be asymmetric; consider check_symmetry=False&quot;</span><span class="p">)</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">diagonal</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">c</span><span class="p">):</span>
                    <span class="n">v</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">c</span><span class="p">):</span>
                    <span class="n">v</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">v</span>
</div>
<div class="viewcode-block" id="Matrix.get_diag_blocks"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.get_diag_blocks">[docs]</a>    <span class="k">def</span> <span class="nf">get_diag_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Obtains the square sub-matrices on the main diagonal of a square matrix.</span>

<span class="sd">        Useful for inverting symbolic matrices or solving systems of</span>
<span class="sd">        linear equations which may be decoupled by having a block diagonal</span>
<span class="sd">        structure.</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix, symbols</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y, z</span>
<span class="sd">        &gt;&gt;&gt; A = Matrix([[1, 3, 0, 0], [y, z*z, 0, 0], [0, 0, x, 0], [0, 0, 0, 0]])</span>
<span class="sd">        &gt;&gt;&gt; a1, a2, a3 = A.get_diag_blocks()</span>
<span class="sd">        &gt;&gt;&gt; a1</span>
<span class="sd">        [1,    3]</span>
<span class="sd">        [y, z**2]</span>
<span class="sd">        &gt;&gt;&gt; a2</span>
<span class="sd">        [x]</span>
<span class="sd">        &gt;&gt;&gt; a3</span>
<span class="sd">        [0]</span>
<span class="sd">        &gt;&gt;&gt;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sub_blocks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">def</span> <span class="nf">recurse_sub_blocks</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">to_the_right</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">:]</span>
                    <span class="n">to_the_bottom</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">to_the_right</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">:]</span>
                    <span class="n">to_the_bottom</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">to_the_right</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">to_the_bottom</span><span class="p">):</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sub_blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                        <span class="k">return</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">recurse_sub_blocks</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">:,</span> <span class="n">i</span><span class="p">:])</span>
                        <span class="k">return</span>
        <span class="n">recurse_sub_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sub_blocks</span>
</div>
<div class="viewcode-block" id="Matrix.diagonalize"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.diagonalize">[docs]</a>    <span class="k">def</span> <span class="nf">diagonalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reals_only</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return diagonalized matrix D and transformation P such as</span>

<span class="sd">            D = P^-1 * M * P</span>

<span class="sd">        where M is current matrix.</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(3,3,[1, 2, 0, 0, 3, 0, 2, -4, 2])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        [1,  2, 0]</span>
<span class="sd">        [0,  3, 0]</span>
<span class="sd">        [2, -4, 2]</span>
<span class="sd">        &gt;&gt;&gt; (P, D) = m.diagonalize()</span>
<span class="sd">        &gt;&gt;&gt; D</span>
<span class="sd">        [1, 0, 0]</span>
<span class="sd">        [0, 2, 0]</span>
<span class="sd">        [0, 0, 3]</span>
<span class="sd">        &gt;&gt;&gt; P</span>
<span class="sd">        [-1/2, 0, -1/2]</span>
<span class="sd">        [   0, 0, -1/2]</span>
<span class="sd">        [   1, 1,    1]</span>
<span class="sd">        &gt;&gt;&gt; P.inv() * m * P</span>
<span class="sd">        [1, 0, 0]</span>
<span class="sd">        [0, 2, 0]</span>
<span class="sd">        [0, 0, 3]</span>

<span class="sd">        See also: .is_diagonalizable(), .is_diagonal()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_diagonalizable</span><span class="p">(</span><span class="n">reals_only</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_diagonalize_clear_subproducts</span><span class="p">()</span>
            <span class="k">raise</span> <span class="n">MatrixError</span><span class="p">(</span><span class="s">&quot;Matrix is not diagonalizable&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eigenvects</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_eigenvects</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvects</span><span class="p">()</span>
            <span class="n">diagvals</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[])</span>
            <span class="k">for</span> <span class="n">eigenval</span><span class="p">,</span> <span class="n">multiplicity</span><span class="p">,</span> <span class="n">vects</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eigenvects</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">multiplicity</span><span class="p">):</span>
                    <span class="n">diagvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eigenval</span><span class="p">)</span>
                    <span class="n">vec</span> <span class="o">=</span> <span class="n">vects</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="n">P</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">col_insert</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">vec</span><span class="p">)</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">diag</span><span class="p">(</span><span class="o">*</span><span class="n">diagvals</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_diagonalize_clear_subproducts</span><span class="p">()</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Matrix.is_diagonalizable"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.is_diagonalizable">[docs]</a>    <span class="k">def</span> <span class="nf">is_diagonalizable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reals_only</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="n">clear_subproducts</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if matrix is diagonalizable.</span>

<span class="sd">        If reals_only==True then check that diagonalized matrix consists of the only not complex values.</span>

<span class="sd">        Some subproducts could be used further in other methods to avoid double calculations,</span>
<span class="sd">        By default (if clear_subproducts==True) they will be deleted.</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(3,3,[1, 2, 0, 0, 3, 0, 2, -4, 2])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        [1,  2, 0]</span>
<span class="sd">        [0,  3, 0]</span>
<span class="sd">        [2, -4, 2]</span>
<span class="sd">        &gt;&gt;&gt; m.is_diagonalizable()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(2,2,[0, 1, 0, 0])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        [0, 1]</span>
<span class="sd">        [0, 0]</span>
<span class="sd">        &gt;&gt;&gt; m.is_diagonalizable()</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(2,2,[0, 1, -1, 0])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        [ 0, 1]</span>
<span class="sd">        [-1, 0]</span>
<span class="sd">        &gt;&gt;&gt; m.is_diagonalizable()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; m.is_diagonalizable(True)</span>
<span class="sd">        False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_symbolic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_symbolic</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_symmetric</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_symmetric</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_eigenvects</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="c">#if self._is_symbolic:</span>
        <span class="c">#    self._diagonalize_clear_subproducts()</span>
        <span class="c">#    raise NotImplementedError(&quot;Symbolic matrices are not implemented for diagonalization yet&quot;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_eigenvects</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvects</span><span class="p">()</span>
        <span class="n">all_iscorrect</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">eigenval</span><span class="p">,</span> <span class="n">multiplicity</span><span class="p">,</span> <span class="n">vects</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eigenvects</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vects</span><span class="p">)</span> <span class="o">!=</span> <span class="n">multiplicity</span><span class="p">:</span>
                <span class="n">all_iscorrect</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">reals_only</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">eigenval</span><span class="o">.</span><span class="n">is_real</span><span class="p">:</span>
                <span class="n">all_iscorrect</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">break</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">all_iscorrect</span>
        <span class="k">if</span> <span class="n">clear_subproducts</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_diagonalize_clear_subproducts</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">res</span>
</div>
    <span class="k">def</span> <span class="nf">_diagonalize_clear_subproducts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_symbolic</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_symmetric</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eigenvects</span>

<div class="viewcode-block" id="Matrix.jordan_form"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.jordan_form">[docs]</a>    <span class="k">def</span> <span class="nf">jordan_form</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calc_transformation</span> <span class="o">=</span> <span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return Jordan form J of current matrix.</span>

<span class="sd">        If calc_transformation is specified as False, then transformation P such that</span>

<span class="sd">              J = P^-1 * M * P</span>

<span class="sd">        will not be calculated.</span>

<span class="sd">        Note:</span>

<span class="sd">        Calculation of transformation P is not implemented yet</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(4, 4, [6, 5, -2, -3, -3, -1, 3, 3, 2, 1, -2, -3, -1, 1, 5, 5])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        [ 6,  5, -2, -3]</span>
<span class="sd">        [-3, -1,  3,  3]</span>
<span class="sd">        [ 2,  1, -2, -3]</span>
<span class="sd">        [-1,  1,  5,  5]</span>

<span class="sd">        &gt;&gt;&gt; (P, J) = m.jordan_form()</span>
<span class="sd">        &gt;&gt;&gt; J</span>
<span class="sd">        [2, 1, 0, 0]</span>
<span class="sd">        [0, 2, 0, 0]</span>
<span class="sd">        [0, 0, 2, 1]</span>
<span class="sd">        [0, 0, 0, 2]</span>

<span class="sd">        See also: jordan_cells()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Jcells</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jordan_cells</span><span class="p">(</span><span class="n">calc_transformation</span><span class="p">)</span>
        <span class="n">J</span> <span class="o">=</span> <span class="n">diag</span><span class="p">(</span><span class="o">*</span><span class="n">Jcells</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">J</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Matrix.jordan_cells"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.jordan_cells">[docs]</a>    <span class="k">def</span> <span class="nf">jordan_cells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calc_transformation</span> <span class="o">=</span> <span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of Jordan cells of current matrix.</span>
<span class="sd">        This list shape Jordan matrix J.</span>

<span class="sd">        If calc_transformation is specified as False, then transformation P such that</span>

<span class="sd">              J = P^-1 * M * P</span>

<span class="sd">        will not be calculated.</span>

<span class="sd">        Note:</span>

<span class="sd">        Calculation of transformation P is not implemented yet</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(4, 4, [6, 5, -2, -3, -3, -1, 3, 3, 2, 1, -2, -3, -1, 1, 5, 5])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        [ 6,  5, -2, -3]</span>
<span class="sd">        [-3, -1,  3,  3]</span>
<span class="sd">        [ 2,  1, -2, -3]</span>
<span class="sd">        [-1,  1,  5,  5]</span>

<span class="sd">        &gt;&gt;&gt; (P, Jcells) = m.jordan_cells()</span>
<span class="sd">        &gt;&gt;&gt; Jcells[0]</span>
<span class="sd">        [2, 1]</span>
<span class="sd">        [0, 2]</span>
<span class="sd">        &gt;&gt;&gt; Jcells[1]</span>
<span class="sd">        [2, 1]</span>
<span class="sd">        [0, 2]</span>

<span class="sd">        See also: jordan_form()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">()</span>
        <span class="n">_eigenvects</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvects</span><span class="p">()</span>
        <span class="n">Jcells</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">eigenval</span><span class="p">,</span> <span class="n">multiplicity</span><span class="p">,</span> <span class="n">vects</span> <span class="ow">in</span> <span class="n">_eigenvects</span><span class="p">:</span>
            <span class="n">geometrical</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vects</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">geometrical</span> <span class="o">==</span> <span class="n">multiplicity</span><span class="p">:</span>
                <span class="n">Jcell</span> <span class="o">=</span> <span class="n">diag</span><span class="p">(</span> <span class="o">*</span><span class="p">([</span><span class="n">eigenval</span><span class="p">]</span> <span class="o">*</span> <span class="n">multiplicity</span><span class="p">))</span>
                <span class="n">Jcells</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Jcell</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">geometrical</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">MatrixError</span><span class="p">(</span><span class="s">&quot;Matrix has the eigen vector with geometrical multiplicity equal zero.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sizes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jordan_split</span><span class="p">(</span><span class="n">multiplicity</span><span class="p">,</span> <span class="n">geometrical</span><span class="p">)</span>
                <span class="n">cells</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">sizes</span><span class="p">:</span>
                    <span class="n">cell</span> <span class="o">=</span> <span class="n">jordan_cell</span><span class="p">(</span><span class="n">eigenval</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
                    <span class="n">cells</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
                <span class="n">Jcells</span> <span class="o">+=</span> <span class="n">cells</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">Jcells</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_jordan_split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">algebraical</span><span class="p">,</span> <span class="n">geometrical</span><span class="p">):</span>
            <span class="s">&quot;return a list which sum is equal to &#39;algebraical&#39; and length is equal to &#39;geometrical&#39;&quot;</span>
            <span class="n">n1</span> <span class="o">=</span> <span class="n">algebraical</span> <span class="o">//</span> <span class="n">geometrical</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">n1</span><span class="p">]</span> <span class="o">*</span> <span class="n">geometrical</span>
            <span class="n">res</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">algebraical</span> <span class="o">%</span> <span class="n">geometrical</span>
            <span class="k">assert</span> <span class="nb">sum</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">==</span> <span class="n">algebraical</span>
            <span class="k">return</span> <span class="n">res</span>

<div class="viewcode-block" id="Matrix.has"><a class="viewcode-back" href="../../../modules/matrices.html#sympy.matrices.matrices.Matrix.has">[docs]</a>    <span class="k">def</span> <span class="nf">has</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">patterns</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test whether any subexpression matches any of the patterns.</span>

<span class="sd">        Examples:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix, Float</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; A = Matrix(((1, x), (0.2, 3)))</span>
<span class="sd">        &gt;&gt;&gt; A.has(x)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; A.has(y)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; A.has(Float)</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">patterns</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">)</span>
</div></div>
<span class="k">def</span> <span class="nf">matrix_multiply</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matrix product A*B.</span>

<span class="sd">    A and B must be of appropriate dimensions.  If A is an m x k matrix, and B</span>
<span class="sd">    is a k x n matrix, the product will be an m x n matrix.</span>

<span class="sd">    Example:</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">    &gt;&gt;&gt; A = Matrix([[1, 2, 3], [4, 5, 6]])</span>
<span class="sd">    &gt;&gt;&gt; B = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])</span>
<span class="sd">    &gt;&gt;&gt; A*B</span>
<span class="sd">    [30, 36, 42]</span>
<span class="sd">    [66, 81, 96]</span>
<span class="sd">    &gt;&gt;&gt; B*A</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ShapeError</span>
<span class="sd">    &gt;&gt;&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># The following implmentation is equivalent, but about 5% slower</span>
    <span class="c">#ma, na = A.shape</span>
    <span class="c">#mb, nb = B.shape</span>
    <span class="c">#</span>
    <span class="c">#if na != mb:</span>
    <span class="c">#    raise ShapeError()</span>
    <span class="c">#product = Matrix(ma, nb, lambda i,j: 0)</span>
    <span class="c">#for i in xrange(ma):</span>
    <span class="c">#    for j in xrange(nb):</span>
    <span class="c">#        s = 0</span>
    <span class="c">#        for k in range(na):</span>
    <span class="c">#            s += A[i, k]*B[k, j]</span>
    <span class="c">#        product[i, j] = s</span>
    <span class="c">#return product</span>
    <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="n">ShapeError</span><span class="p">()</span>
    <span class="n">blst</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">alst</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span>
                                        <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="n">k</span><span class="o">+</span><span class="n">l</span><span class="p">,</span>
                                        <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="n">n</span><span class="o">*</span><span class="n">m</span><span class="p">,</span>
                                        <span class="n">alst</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                        <span class="n">blst</span><span class="p">[</span><span class="n">j</span><span class="p">])))</span>

<span class="k">def</span> <span class="nf">matrix_multiply_elementwise</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the Hadamard product (elementwise product) of A and B</span>

<span class="sd">    &gt;&gt;&gt; import sympy</span>
<span class="sd">    &gt;&gt;&gt; A = sympy.Matrix([[0, 1, 2], [3, 4, 5]])</span>
<span class="sd">    &gt;&gt;&gt; B = sympy.Matrix([[1, 10, 100], [100, 10, 1]])</span>
<span class="sd">    &gt;&gt;&gt; print sympy.matrices.matrix_multiply_elementwise(A, B)</span>
<span class="sd">    [  0, 10, 200]</span>
<span class="sd">    [300, 40,   5]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ShapeError</span><span class="p">()</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">matrix_add</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return A+B&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ShapeError</span><span class="p">()</span>
    <span class="n">alst</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">blst</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">ret</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">:</span> <span class="n">j</span><span class="o">+</span><span class="n">k</span><span class="p">,</span> <span class="n">alst</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">blst</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">zeros</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create zero matrix of dimensions dims = (d1,d2)&quot;&quot;&quot;</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">_dims_to_nm</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="p">[</span><span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">]</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">n</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">ones</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create all-one matrix of dimensions dims = (d1,d2)&quot;&quot;&quot;</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">_dims_to_nm</span><span class="p">(</span> <span class="n">dims</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="p">[</span><span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">]</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">n</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">eye</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create square identity matrix n x n</span>

<span class="sd">    See also: diag()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
    <span class="k">return</span> <span class="n">out</span>

<span class="k">def</span> <span class="nf">diag</span><span class="p">(</span><span class="o">*</span><span class="n">values</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create diagonal matrix from a list as a diagonal values.</span>

<span class="sd">    Arguments might be matrices too, in case of it they are fitted in result matrix</span>

<span class="sd">    Example:</span>

<span class="sd">    &gt;&gt;&gt; from sympy.matrices import diag, Matrix</span>
<span class="sd">    &gt;&gt;&gt; diag(1, 2, 3)</span>
<span class="sd">    [1, 0, 0]</span>
<span class="sd">    [0, 2, 0]</span>
<span class="sd">    [0, 0, 3]</span>

<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y, z</span>
<span class="sd">    &gt;&gt;&gt; a = Matrix([x, y, z])</span>
<span class="sd">    &gt;&gt;&gt; b = Matrix([[1, 2], [3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; c = Matrix([[5, 6]])</span>
<span class="sd">    &gt;&gt;&gt; diag(a, 7, b, c)</span>
<span class="sd">    [x, 0, 0, 0, 0, 0]</span>
<span class="sd">    [y, 0, 0, 0, 0, 0]</span>
<span class="sd">    [z, 0, 0, 0, 0, 0]</span>
<span class="sd">    [0, 7, 0, 0, 0, 0]</span>
<span class="sd">    [0, 0, 1, 2, 0, 0]</span>
<span class="sd">    [0, 0, 3, 4, 0, 0]</span>
<span class="sd">    [0, 0, 0, 0, 5, 6]</span>

<span class="sd">    See also: eye()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rows</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">cols</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">):</span>
            <span class="n">rows</span> <span class="o">+=</span> <span class="n">m</span><span class="o">.</span><span class="n">rows</span>
            <span class="n">cols</span> <span class="o">+=</span> <span class="n">m</span><span class="o">.</span><span class="n">cols</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rows</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">cols</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">))</span>
    <span class="n">i_row</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">i_col</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">):</span>
            <span class="n">res</span><span class="p">[</span><span class="n">i_row</span><span class="p">:</span><span class="n">i_row</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="n">i_col</span><span class="p">:</span><span class="n">i_col</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="n">cols</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span>
            <span class="n">i_row</span> <span class="o">+=</span> <span class="n">m</span><span class="o">.</span><span class="n">rows</span>
            <span class="n">i_col</span> <span class="o">+=</span> <span class="n">m</span><span class="o">.</span><span class="n">cols</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span><span class="p">[</span><span class="n">i_row</span><span class="p">,</span> <span class="n">i_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span>
            <span class="n">i_row</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">i_col</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">res</span>

<span class="k">def</span> <span class="nf">block_diag</span><span class="p">(</span><span class="n">matrices</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Warning: this function is deprecated. See .diag()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">warnings</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;block_diag() is deprecated, use diag() instead&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">diag</span><span class="p">(</span><span class="o">*</span><span class="n">matrices</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">jordan_cell</span><span class="p">(</span><span class="n">eigenval</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create matrix of Jordan cell kind:</span>

<span class="sd">    Example:</span>

<span class="sd">    &gt;&gt;&gt; from sympy.matrices.matrices import jordan_cell</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; jordan_cell(x, 4)</span>
<span class="sd">    [x, 1, 0, 0]</span>
<span class="sd">    [0, x, 1, 0]</span>
<span class="sd">    [0, 0, x, 1]</span>
<span class="sd">    [0, 0, 0, x]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">eigenval</span>
        <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
    <span class="n">out</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">eigenval</span>
    <span class="k">return</span> <span class="n">out</span>

<span class="k">def</span> <span class="nf">randMatrix</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="nb">max</span><span class="o">=</span><span class="mi">99</span><span class="p">,</span><span class="n">seed</span><span class="o">=</span><span class="p">[]):</span>
    <span class="sd">&quot;&quot;&quot;Create random matrix r x c&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">seed</span> <span class="o">==</span> <span class="p">[]:</span>
        <span class="n">prng</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">Random</span><span class="p">()</span>  <span class="c"># use system time</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">prng</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">Random</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="k">lambda</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">:</span> <span class="n">prng</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span><span class="nb">max</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">hessian</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">varlist</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute Hessian matrix for a function f</span>

<span class="sd">    see: http://en.wikipedia.org/wiki/Hessian_matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># f is the expression representing a function f, return regular matrix</span>
    <span class="k">if</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">varlist</span><span class="p">):</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">varlist</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ShapeError</span><span class="p">(</span><span class="s">&quot;`len(varlist)` must not be zero.&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">varlist</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">):</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">varlist</span><span class="o">.</span><span class="n">cols</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ShapeError</span><span class="p">(</span><span class="s">&quot;`varlist.cols` must not be zero.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">varlist</span><span class="o">.</span><span class="n">rows</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ShapeError</span><span class="p">(</span><span class="s">&quot;`varlist` must be a row vector.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Improper variable list in hessian function&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">&#39;diff&#39;</span><span class="p">):</span>
        <span class="c"># check differentiability</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Function `f` (</span><span class="si">%s</span><span class="s">) is not differentiable&quot;</span> <span class="o">%</span> <span class="n">f</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">m</span><span class="p">):</span>
            <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">varlist</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">varlist</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">out</span>

<span class="k">def</span> <span class="nf">GramSchmidt</span><span class="p">(</span><span class="n">vlist</span><span class="p">,</span> <span class="n">orthog</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vlist</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">vlist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="n">tmp</span> <span class="o">-=</span> <span class="n">vlist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">tmp</span> <span class="o">==</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;GramSchmidt: vector set not linearly independent&quot;</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">orthog</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)):</span>
            <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">out</span>

<span class="k">def</span> <span class="nf">wronskian</span><span class="p">(</span><span class="n">functions</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;bareis&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute Wronskian for [] of functions</span>

<span class="sd">                   | f1       f2        ...   fn      |</span>
<span class="sd">                   | f1&#39;      f2&#39;       ...   fn&#39;     |</span>
<span class="sd">                   |  .        .        .      .      |</span>
<span class="sd">    W(f1,...,fn) = |  .        .         .     .      |</span>
<span class="sd">                   |  .        .          .    .      |</span>
<span class="sd">                   |  (n)      (n)            (n)     |</span>
<span class="sd">                   | D   (f1) D   (f2)  ...  D   (fn) |</span>

<span class="sd">    see: http://en.wikipedia.org/wiki/Wronskian</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">functions</span><span class="p">)):</span>
        <span class="n">functions</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">functions</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">functions</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="n">W</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">:</span> <span class="n">functions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">W</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">casoratian</span><span class="p">(</span><span class="n">seqs</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">zero</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given linear difference operator L of order &#39;k&#39; and homogeneous</span>
<span class="sd">       equation Ly = 0 we want to compute kernel of L, which is a set</span>
<span class="sd">       of &#39;k&#39; sequences: a(n), b(n), ... z(n).</span>

<span class="sd">       Solutions of L are linearly independent iff their Casoratian,</span>
<span class="sd">       denoted as C(a, b, ..., z), do not vanish for n = 0.</span>

<span class="sd">       Casoratian is defined by k x k determinant:</span>

<span class="sd">                  +  a(n)     b(n)     . . . z(n)     +</span>
<span class="sd">                  |  a(n+1)   b(n+1)   . . . z(n+1)   |</span>
<span class="sd">                  |    .         .     .        .     |</span>
<span class="sd">                  |    .         .       .      .     |</span>
<span class="sd">                  |    .         .         .    .     |</span>
<span class="sd">                  +  a(n+k-1) b(n+k-1) . . . z(n+k-1) +</span>

<span class="sd">       It proves very useful in rsolve_hyper() where it is applied</span>
<span class="sd">       to a generating set of a recurrence to factor out linearly</span>
<span class="sd">       dependent solutions and return a basis.</span>

<span class="sd">       &gt;&gt;&gt; from sympy import Symbol, casoratian, factorial</span>
<span class="sd">       &gt;&gt;&gt; n = Symbol(&#39;n&#39;, integer=True)</span>

<span class="sd">       Exponential and factorial are linearly independent:</span>

<span class="sd">       &gt;&gt;&gt; casoratian([2**n, factorial(n)], n) != 0</span>
<span class="sd">       True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">seqs</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">sympify</span><span class="p">,</span> <span class="n">seqs</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">zero</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">seqs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="n">i</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">seqs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

    <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">det</span><span class="p">()</span>

<span class="c"># Add sympify converters</span>
<span class="k">def</span> <span class="nf">_matrix_sympify</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">SympifyError</span><span class="p">(</span><span class="s">&#39;Matrix cannot be sympified&#39;</span><span class="p">)</span>
<span class="n">converter</span><span class="p">[</span><span class="n">Matrix</span><span class="p">]</span> <span class="o">=</span> <span class="n">_matrix_sympify</span>
<span class="k">del</span> <span class="n">_matrix_sympify</span>


<span class="k">class</span> <span class="nc">SparseMatrix</span><span class="p">(</span><span class="n">Matrix</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Sparse matrix&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="nb">callable</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">Integer</span><span class="p">))</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">Integer</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;`args[0]` and `args[1]` must both be integers.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mat</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">value</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mat</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="o">+</span><span class="n">j</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">value</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mat</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="c"># manual copy, copy.deepcopy() doesn&#39;t work</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">key</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">args</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">mat</span> <span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mat</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;All arguments must have the same length.&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">value</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice2bounds</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="n">L</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">):</span>
                <span class="n">m</span><span class="p">,</span><span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rowdecomp</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">:</span>
                    <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">[(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">L</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;`key` must be of length 2.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">key2ij</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">slice</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">submatrix</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s">&quot;Index out of range: a[</span><span class="si">%s</span><span class="s">]&quot;</span><span class="o">%</span><span class="nb">repr</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">rowdecomp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
        <span class="n">nmax</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="n">nmax</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">num</span> <span class="o">&lt;</span> <span class="n">nmax</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;`num` must satisfy 0 &lt;= `num` &lt; `self.rows*&quot;</span> <span class="o">+</span>
                <span class="s">&quot;*self.cols` (</span><span class="si">%d</span><span class="s">) and 0 &lt;= -num &lt; &quot;</span> <span class="o">%</span> <span class="n">nmax</span> <span class="o">+</span>
                <span class="s">&quot;`self.rows*self.cols` (</span><span class="si">%d</span><span class="s">) to apply redecomp().&quot;</span> <span class="o">%</span> <span class="n">nmax</span><span class="p">)</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">num</span>
        <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c"># almost identical, need to test for 0</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;`key` must be of length 2.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">slice</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">copyin_matrix</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">copyin_list</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">key2ij</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="n">testval</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">testval</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="n">testval</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">row_del</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="n">newD</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="n">k</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">:</span>
                <span class="n">newD</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newD</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mat</span> <span class="o">=</span> <span class="n">newD</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">col_del</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="n">newD</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">j</span><span class="o">==</span><span class="n">k</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">:</span>
                <span class="n">newD</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newD</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mat</span> <span class="o">=</span> <span class="n">newD</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">toMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
            <span class="n">c</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">:</span>
                    <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">row_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a Row-sorted list of non-zero elements of the matrix.</span>

<span class="sd">        &gt;&gt;&gt; from sympy.matrices import SparseMatrix</span>
<span class="sd">        &gt;&gt;&gt; a=SparseMatrix((1,2),(3,4))</span>
<span class="sd">        &gt;&gt;&gt; a</span>
<span class="sd">        [1, 2]</span>
<span class="sd">        [3, 4]</span>
<span class="sd">        &gt;&gt;&gt; a.RL</span>
<span class="sd">        [(0, 0, 1), (0, 1, 2), (1, 0, 3), (1, 1, 4)]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">new</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span>
                <span class="k">if</span> <span class="n">value</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">new</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">value</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">new</span>

    <span class="n">RL</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">row_list</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="s">&quot;Alternate faster representation&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">col_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a Column-sorted list of non-zero elements of the matrix.</span>
<span class="sd">        &gt;&gt;&gt; from sympy.matrices import SparseMatrix</span>
<span class="sd">        &gt;&gt;&gt; a=SparseMatrix((1,2),(3,4))</span>
<span class="sd">        &gt;&gt;&gt; a</span>
<span class="sd">        [1, 2]</span>
<span class="sd">        [3, 4]</span>
<span class="sd">        &gt;&gt;&gt; a.CL</span>
<span class="sd">        [(0, 0, 1), (1, 0, 3), (0, 1, 2), (1, 1, 4)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span>
                <span class="k">if</span> <span class="n">value</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">new</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">value</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">new</span>

    <span class="n">CL</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">col_list</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="s">&quot;Alternate faster representation&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the transposed SparseMatrix of this SparseMatrix</span>
<span class="sd">        &gt;&gt;&gt; from sympy.matrices import SparseMatrix</span>
<span class="sd">        &gt;&gt;&gt; a = SparseMatrix((1,2),(3,4))</span>
<span class="sd">        &gt;&gt;&gt; a</span>
<span class="sd">        [1, 2]</span>
<span class="sd">        [3, 4]</span>
<span class="sd">        &gt;&gt;&gt; a.T</span>
<span class="sd">        [1, 3]</span>
<span class="sd">        [2, 4]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tran</span> <span class="o">=</span> <span class="n">SparseMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,{})</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="n">tran</span><span class="o">.</span><span class="n">mat</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">=</span><span class="n">value</span>
        <span class="k">return</span> <span class="n">tran</span>

    <span class="n">T</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">transpose</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="s">&quot;Matrix transposition.&quot;</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">SparseMatrix</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Only SparseMatrix + SparseMatrix supported&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">SparseMatrix</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Only SparseMatrix + SparseMatrix supported&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add two sparse matrices with dictionary representation.</span>

<span class="sd">        &gt;&gt;&gt; from sympy.matrices.matrices import SparseMatrix</span>
<span class="sd">        &gt;&gt;&gt; A = SparseMatrix(5, 5, lambda i, j : i * j + i)</span>
<span class="sd">        &gt;&gt;&gt; A</span>
<span class="sd">        [0, 0,  0,  0,  0]</span>
<span class="sd">        [1, 2,  3,  4,  5]</span>
<span class="sd">        [2, 4,  6,  8, 10]</span>
<span class="sd">        [3, 6,  9, 12, 15]</span>
<span class="sd">        [4, 8, 12, 16, 20]</span>
<span class="sd">        &gt;&gt;&gt; B = SparseMatrix(5, 5, lambda i, j : i + 2 * j)</span>
<span class="sd">        &gt;&gt;&gt; B</span>
<span class="sd">        [0, 2, 4,  6,  8]</span>
<span class="sd">        [1, 3, 5,  7,  9]</span>
<span class="sd">        [2, 4, 6,  8, 10]</span>
<span class="sd">        [3, 5, 7,  9, 11]</span>
<span class="sd">        [4, 6, 8, 10, 12]</span>
<span class="sd">        &gt;&gt;&gt; A + B</span>
<span class="sd">        [0,  2,  4,  6,  8]</span>
<span class="sd">        [2,  5,  8, 11, 14]</span>
<span class="sd">        [4,  8, 12, 16, 20]</span>
<span class="sd">        [6, 11, 16, 21, 26]</span>
<span class="sd">        [8, 14, 20, 26, 32]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ShapeError</span><span class="p">()</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">other</span><span class="o">.</span><span class="n">mat</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="n">a</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">b</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">and</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">]):</span>
                <span class="n">c</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="ow">and</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">]):</span>
                <span class="n">c</span><span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">mat</span><span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">c</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">mat</span><span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>



    <span class="c"># from here to end all functions are same as in matrices.py</span>
    <span class="c"># with Matrix replaced with SparseMatrix</span>
    <span class="k">def</span> <span class="nf">copyin_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;`value` must be of type list or tuple.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copyin_matrix</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">SparseMatrix</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns self*b &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">dotprod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">cols</span> <span class="o">!=</span> <span class="n">b</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ShapeError</span><span class="p">(</span><span class="s">&quot;`self.cols` must equal `b.rows`.&quot;</span><span class="p">)</span>
            <span class="n">r</span><span class="o">=</span><span class="mi">0</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
                <span class="n">r</span><span class="o">+=</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">x</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">r</span>

        <span class="n">r</span> <span class="o">=</span> <span class="n">SparseMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">:</span> <span class="n">dotprod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">rows</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">r</span><span class="o">.</span><span class="n">cols</span> <span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">r</span>

    <span class="k">def</span> <span class="nf">submatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">slice</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Both elements of `keys` must be slice objects.&quot;</span><span class="p">)</span>
        <span class="n">rlo</span><span class="p">,</span> <span class="n">rhi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice2bounds</span><span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">)</span>
        <span class="n">clo</span><span class="p">,</span> <span class="n">chi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice2bounds</span><span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span> <span class="mi">0</span><span class="o">&lt;=</span><span class="n">rlo</span><span class="o">&lt;=</span><span class="n">rhi</span> <span class="ow">and</span> <span class="mi">0</span><span class="o">&lt;=</span><span class="n">clo</span><span class="o">&lt;=</span><span class="n">chi</span> <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s">&quot;Slice indices out of range: a[</span><span class="si">%s</span><span class="s">]&quot;</span><span class="o">%</span><span class="nb">repr</span><span class="p">(</span><span class="n">keys</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span><span class="n">rhi</span><span class="o">-</span><span class="n">rlo</span><span class="p">,</span> <span class="n">chi</span><span class="o">-</span><span class="n">clo</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">:</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">rlo</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="n">clo</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">reshape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_rows</span><span class="p">,</span> <span class="n">_cols</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="n">_rows</span><span class="o">*</span><span class="n">_cols</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Invalid reshape parameters </span><span class="si">%d</span><span class="s"> </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">_rows</span><span class="p">,</span> <span class="n">_cols</span><span class="p">)</span>
        <span class="n">newD</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">_rows</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">_cols</span><span class="p">):</span>
                <span class="n">m</span><span class="p">,</span><span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rowdecomp</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">_cols</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">:</span>
                    <span class="n">newD</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">[(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span><span class="n">_rows</span><span class="p">,</span> <span class="n">_cols</span><span class="p">,</span> <span class="n">newD</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cross</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="n">Matrix</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;`b` must be an ordered iterable or Matrix, not </span><span class="si">%s</span><span class="s">.&quot;</span> <span class="o">%</span>
                <span class="nb">type</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">or</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">)</span> <span class="ow">and</span> \
                <span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">rows</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">cols</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">or</span> \
                <span class="n">b</span><span class="o">.</span><span class="n">rows</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">cols</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ShapeError</span><span class="p">(</span><span class="s">&quot;Dimensions incorrect for cross product&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,((</span><span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                               <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
                               <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>


    <span class="k">def</span> <span class="nf">zeros</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dims</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a dims = (d1,d2) matrix of zeros.&quot;&quot;&quot;</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">_dims_to_nm</span><span class="p">(</span> <span class="n">dims</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">,{})</span>

    <span class="k">def</span> <span class="nf">eye</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">SparseMatrix</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="k">lambda</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">:</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
            <span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">tmp</span>


<span class="k">def</span> <span class="nf">list2numpy</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converts python list of SymPy expressions to a NumPy array.&quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">empty</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>
    <span class="k">return</span> <span class="n">a</span>

<span class="k">def</span> <span class="nf">matrix2numpy</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converts SymPy&#39;s matrix to a NumPy array.&quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">empty</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
            <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">a</span>

<span class="k">def</span> <span class="nf">a2idx</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tries to convert &quot;a&quot; to an index, returns None on failure.</span>

<span class="sd">    The result of a2idx() (if not None) can be safely used as an index to</span>
<span class="sd">    arrays/matrices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&quot;__int__&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&quot;__index__&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">__index__</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">symarray</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a numpy ndarray of symbols (as an object array).</span>

<span class="sd">    The created symbols are named prefix_i1_i2_...  You should thus provide a</span>
<span class="sd">    non-empty prefix if you want your symbols to be unique for different output</span>
<span class="sd">    arrays, as Sympy symbols with identical names are the same object.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    prefix : string</span>
<span class="sd">      A prefix prepended to the name of every symbol.</span>

<span class="sd">    shape : int or tuple</span>
<span class="sd">      Shape of the created array.  If an int, the array is one-dimensional; for</span>
<span class="sd">      more than one dimension the shape must be a tuple.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt; from sympy import symarray</span>
<span class="sd">    &gt;&gt; symarray(&#39;&#39;, 3)</span>
<span class="sd">    [_0 _1 _2]</span>

<span class="sd">    If you want multiple symarrays to contain distinct symbols, you *must*</span>
<span class="sd">    provide unique prefixes:</span>

<span class="sd">    &gt;&gt; a = symarray(&#39;&#39;, 3)</span>
<span class="sd">    &gt;&gt; b = symarray(&#39;&#39;, 3)</span>
<span class="sd">    &gt;&gt; a[0] is b[0]</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt; a = symarray(&#39;a&#39;, 3)</span>
<span class="sd">    &gt;&gt; b = symarray(&#39;b&#39;, 3)</span>
<span class="sd">    &gt;&gt; a[0] is b[0]</span>
<span class="sd">    False</span>

<span class="sd">    Creating symarrays with a prefix:</span>
<span class="sd">    &gt;&gt; symarray(&#39;a&#39;, 3)</span>
<span class="sd">    [a_0 a_1 a_2]</span>

<span class="sd">    For more than one dimension, the shape must be given as a tuple:</span>
<span class="sd">    &gt;&gt; symarray(&#39;a&#39;, (2,3))</span>
<span class="sd">    [[a_0_0 a_0_1 a_0_2]</span>
<span class="sd">    [a_1_0 a_1_1 a_1_2]]</span>
<span class="sd">    &gt;&gt; symarray(&#39;a&#39;, (2,3,2))</span>
<span class="sd">    [[[a_0_0_0 a_0_0_1]</span>
<span class="sd">      [a_0_1_0 a_0_1_1]</span>
<span class="sd">      [a_0_2_0 a_0_2_1]]</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">     [[a_1_0_0 a_1_0_1]</span>
<span class="sd">      [a_1_1_0 a_1_1_1]</span>
<span class="sd">      [a_1_2_0 a_1_2_1]]]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s">&quot;symarray requires numpy to be installed&quot;</span><span class="p">)</span>

    <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">_</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="s">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">index</span><span class="p">))))</span>
    <span class="k">return</span> <span class="n">arr</span>

<span class="k">def</span> <span class="nf">_separate_eig_results</span><span class="p">(</span><span class="n">res</span><span class="p">):</span>
    <span class="n">eigvals</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">res</span><span class="p">]</span>
    <span class="n">multiplicities</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">res</span><span class="p">]</span>
    <span class="n">eigvals</span> <span class="o">=</span> <span class="n">flatten</span><span class="p">([[</span><span class="n">val</span><span class="p">]</span><span class="o">*</span><span class="n">mult</span> <span class="k">for</span> <span class="n">val</span><span class="p">,</span> <span class="n">mult</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">eigVals</span><span class="p">,</span> <span class="n">multiplicities</span><span class="p">)])</span>
    <span class="n">eigvects</span> <span class="o">=</span> <span class="n">flatten</span><span class="p">([</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">res</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">eigvals</span><span class="p">,</span> <span class="n">eigvects</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SymPy v0.7.1 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../sympy.html" >sympy</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2008, 2009, 2010, 2011 SymPy Development Team.
      Last updated on Jul 29, 2011.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>