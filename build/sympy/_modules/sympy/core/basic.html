

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>sympy.core.basic &mdash; SymPy v0.7.1 documentation</title>
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.7.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <link rel="top" title="SymPy v0.7.1 documentation" href="../../../index.html" />
    <link rel="up" title="sympy" href="../../sympy.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SymPy v0.7.1 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../sympy.html" accesskey="U">sympy</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for sympy.core.basic</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;Base class for all the objects in SymPy&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">assumptions</span> <span class="kn">import</span> <span class="n">AssumeMeths</span><span class="p">,</span> <span class="n">make__get_assumption</span>
<span class="kn">from</span> <span class="nn">cache</span> <span class="kn">import</span> <span class="n">cacheit</span>
<span class="kn">from</span> <span class="nn">core</span> <span class="kn">import</span> <span class="n">BasicMeta</span><span class="p">,</span> <span class="n">BasicType</span><span class="p">,</span> <span class="n">C</span>
<span class="kn">from</span> <span class="nn">sympify</span> <span class="kn">import</span> <span class="n">_sympify</span><span class="p">,</span> <span class="n">sympify</span><span class="p">,</span> <span class="n">SympifyError</span>
<span class="kn">from</span> <span class="nn">compatibility</span> <span class="kn">import</span> <span class="nb">callable</span><span class="p">,</span> <span class="nb">reduce</span><span class="p">,</span> <span class="nb">cmp</span><span class="p">,</span> <span class="n">iterable</span>
<span class="kn">from</span> <span class="nn">sympy.core.decorators</span> <span class="kn">import</span> <span class="n">deprecated</span>

<div class="viewcode-block" id="Basic"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.basic.Basic">[docs]</a><span class="k">class</span> <span class="nc">Basic</span><span class="p">(</span><span class="n">AssumeMeths</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for all objects in sympy.</span>

<span class="sd">    Conventions:</span>

<span class="sd">    1)</span>
<span class="sd">    When you want to access parameters of some instance, always use .args:</span>
<span class="sd">    Example:</span>

<span class="sd">    &gt;&gt;&gt; from sympy import symbols, cot</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y</span>

<span class="sd">    &gt;&gt;&gt; cot(x).args</span>
<span class="sd">    (x,)</span>

<span class="sd">    &gt;&gt;&gt; cot(x).args[0]</span>
<span class="sd">    x</span>

<span class="sd">    &gt;&gt;&gt; (x*y).args</span>
<span class="sd">    (x, y)</span>

<span class="sd">    &gt;&gt;&gt; (x*y).args[1]</span>
<span class="sd">    y</span>


<span class="sd">    2) Never use internal methods or variables (the ones prefixed with &quot;_&quot;).</span>
<span class="sd">    Example:</span>

<span class="sd">    &gt;&gt;&gt; cot(x)._args    #don&#39;t use this, use cot(x).args instead</span>
<span class="sd">    (x,)</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">BasicMeta</span>

    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;_mhash&#39;</span><span class="p">,</span>              <span class="c"># hash value</span>
                 <span class="s">&#39;_args&#39;</span><span class="p">,</span>               <span class="c"># arguments</span>
                 <span class="s">&#39;_assume_type_keys&#39;</span><span class="p">,</span>   <span class="c"># assumptions typeinfo keys</span>
                <span class="p">]</span>

    <span class="c"># To be overridden with True in the appropriate subclasses</span>
    <span class="n">is_Atom</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">is_Symbol</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">is_Dummy</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">is_Wild</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">is_Function</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">is_Add</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">is_Mul</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">is_Pow</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">is_Number</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">is_Float</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">is_Rational</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">is_Integer</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">is_NumberSymbol</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">is_Order</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">is_Derivative</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">is_Piecewise</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">is_Poly</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">is_AlgebraicNumber</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">is_Relational</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">is_Equality</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">is_Boolean</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">is_Not</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="nd">@property</span>
    <span class="nd">@deprecated</span>
<div class="viewcode-block" id="Basic.is_Real"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.basic.Basic.is_Real">[docs]</a>    <span class="k">def</span> <span class="nf">is_Real</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c"># pragma: no cover</span>
        <span class="sd">&quot;&quot;&quot;Deprecated alias for ``is_Float``&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Float</span>
</div>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">assumptions</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>

        <span class="c"># FIXME we are slowed a *lot* by Add/Mul passing is_commutative as the</span>
        <span class="c"># only assumption.</span>
        <span class="c">#</span>
        <span class="c"># .is_commutative is not an assumption -- it&#39;s like typeinfo!!!</span>
        <span class="c"># we should remove it.</span>

        <span class="c"># initially assumptions are shared between instances and class</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_assumptions</span>  <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">default_assumptions</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_a_inprogress</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c"># NOTE this could be made lazy -- probably not all instances will need</span>
        <span class="c"># fully derived assumptions?</span>
        <span class="k">if</span> <span class="n">assumptions</span><span class="p">:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">_learn_new_facts</span><span class="p">(</span><span class="n">assumptions</span><span class="p">)</span>
            <span class="c">#                      ^</span>
            <span class="c"># FIXME this is slow   |    another NOTE: speeding this up is *not*</span>
            <span class="c">#        |             |    important. say for %timeit x+y most of</span>
            <span class="c"># .------&#39;             |    the time is spent elsewhere</span>
            <span class="c"># |                    |</span>
            <span class="c"># |  XXX _learn_new_facts  could be asked about what *new* facts have</span>
            <span class="c"># v  XXX been learned -- we&#39;ll need this to append to _hashable_content</span>
            <span class="n">basek</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">default_assumptions</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">k2</span>    <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">_assumptions</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">newk</span>  <span class="o">=</span> <span class="n">k2</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">basek</span><span class="p">)</span>

            <span class="n">obj</span><span class="o">.</span><span class="n">_assume_type_keys</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">newk</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">_assume_type_keys</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="n">obj</span><span class="o">.</span><span class="n">_mhash</span> <span class="o">=</span> <span class="bp">None</span> <span class="c"># will be set by __hash__ method.</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_args</span> <span class="o">=</span> <span class="n">args</span>  <span class="c"># all items in args must be Basic objects</span>
        <span class="k">return</span> <span class="n">obj</span>


    <span class="c"># XXX better name?</span>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Basic.assumptions0"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.basic.Basic.assumptions0">[docs]</a>    <span class="k">def</span> <span class="nf">assumptions0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return object ``type`` assumptions.</span>

<span class="sd">        For example:</span>

<span class="sd">          Symbol(&#39;x&#39;, real=True)</span>
<span class="sd">          Symbol(&#39;x&#39;, integer=True)</span>

<span class="sd">        are different objects. In other words, besides Python type (Symbol in</span>
<span class="sd">        this case), the initial assumptions are also forming their typeinfo.</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Symbol</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">        &gt;&gt;&gt; x.assumptions0</span>
<span class="sd">        {}</span>
<span class="sd">        &gt;&gt;&gt; x = Symbol(&quot;x&quot;, positive=True)</span>
<span class="sd">        &gt;&gt;&gt; x.assumptions0</span>
<span class="sd">        {&#39;commutative&#39;: True, &#39;complex&#39;: True, &#39;imaginary&#39;: False,</span>
<span class="sd">        &#39;negative&#39;: False, &#39;nonnegative&#39;: True, &#39;nonpositive&#39;: False,</span>
<span class="sd">        &#39;nonzero&#39;: True, &#39;positive&#39;: True, &#39;real&#39;: True, &#39;zero&#39;: False}</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">A</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assumptions</span>

        <span class="c"># assumptions shared:</span>
        <span class="k">if</span> <span class="n">A</span> <span class="ow">is</span> <span class="n">cls</span><span class="o">.</span><span class="n">default_assumptions</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_assume_type_keys</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>
            <span class="n">assumptions0</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">assumptions0</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assume_type_keys</span> <span class="p">)</span>

        <span class="k">return</span> <span class="n">assumptions0</span>


    <span class="c"># NOTE NOTE NOTE</span>
    <span class="c"># --------------</span>
    <span class="c">#</span>
    <span class="c"># new-style classes + __getattr__ is *very* slow!</span>

    <span class="c"># def __getattr__(self, name):</span>
    <span class="c">#     raise Warning(&#39;no way, *all* attribute access will be 2.5x slower&#39;)</span>

    <span class="c"># here is what we do instead:</span></div>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">AssumeMeths</span><span class="o">.</span><span class="n">_assume_defined</span><span class="p">:</span>
        <span class="k">exec</span> <span class="s">&quot;is_</span><span class="si">%s</span><span class="s">  = property(make__get_assumption(&#39;Basic&#39;, &#39;</span><span class="si">%s</span><span class="s">&#39;))&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>
    <span class="k">del</span> <span class="n">k</span>

    <span class="c"># NB: there is no need in protective __setattr__</span>

    <span class="k">def</span> <span class="nf">__getnewargs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Pickling support.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># hash cannot be cached using cache_it because infinite recurrence</span>
        <span class="c"># occurs as hash is needed for setting cache dictionary keys</span>
        <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mhash</span>
        <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span><span class="p">,)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hashable_content</span><span class="p">()</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assume_type_keys</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">kv</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assumptions</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_assume_type_keys</span><span class="p">):</span>
                    <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">kv</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="p">)</span>

                <span class="n">h</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span> <span class="n">h</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">h</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span> <span class="n">h</span> <span class="p">)</span>


            <span class="bp">self</span><span class="o">.</span><span class="n">_mhash</span> <span class="o">=</span> <span class="n">h</span>
            <span class="k">return</span> <span class="n">h</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">h</span>

    <span class="k">def</span> <span class="nf">_hashable_content</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># If class defines additional attributes, like name in Symbol,</span>
        <span class="c"># then this method should be updated accordingly to return</span>
        <span class="c"># relevant attributes as tuple.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_args</span>

<div class="viewcode-block" id="Basic.compare"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.basic.Basic.compare">[docs]</a>    <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return -1,0,1 if the object is smaller, equal, or greater than other.</span>

<span class="sd">        Not in the mathematical sense. If the object is of a different type</span>
<span class="sd">        from the &quot;other&quot; then their classes are ordered according to</span>
<span class="sd">        the sorted_classes list.</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; x.compare(y)</span>
<span class="sd">        -1</span>
<span class="sd">        &gt;&gt;&gt; x.compare(x)</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; y.compare(x)</span>
<span class="sd">        1</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># all redefinitions of __cmp__ method should start with the</span>
        <span class="c"># following three lines:</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>
        <span class="n">c</span> <span class="o">=</span> <span class="nb">cmp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">__class__</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">c</span><span class="p">:</span> <span class="k">return</span> <span class="n">c</span>
        <span class="c">#</span>
        <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hashable_content</span><span class="p">()</span>
        <span class="n">ot</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_hashable_content</span><span class="p">()</span>
        <span class="n">c</span> <span class="o">=</span> <span class="nb">cmp</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">ot</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">c</span><span class="p">:</span> <span class="k">return</span> <span class="n">c</span>
        <span class="k">for</span> <span class="n">l</span><span class="p">,</span><span class="n">r</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">st</span><span class="p">,</span><span class="n">ot</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">Basic</span><span class="p">):</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="nb">cmp</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">c</span><span class="p">:</span> <span class="k">return</span> <span class="n">c</span>
        <span class="k">return</span> <span class="mi">0</span>
</div>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_compare_pretty</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy.series.order</span> <span class="kn">import</span> <span class="n">Order</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Order</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">Order</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Order</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">Order</span><span class="p">):</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_Rational</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">cmp</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">p</span><span class="o">*</span><span class="n">b</span><span class="o">.</span><span class="n">q</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">q</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">sympy.core.symbol</span> <span class="kn">import</span> <span class="n">Wild</span>
            <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&quot;p1&quot;</span><span class="p">),</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&quot;p2&quot;</span><span class="p">),</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&quot;p3&quot;</span><span class="p">)</span>
            <span class="n">r_a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p1</span> <span class="o">*</span> <span class="n">p2</span><span class="o">**</span><span class="n">p3</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">r_a</span> <span class="ow">and</span> <span class="n">p3</span> <span class="ow">in</span> <span class="n">r_a</span><span class="p">:</span>
                <span class="n">a3</span> <span class="o">=</span> <span class="n">r_a</span><span class="p">[</span><span class="n">p3</span><span class="p">]</span>
                <span class="n">r_b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p1</span> <span class="o">*</span> <span class="n">p2</span><span class="o">**</span><span class="n">p3</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">r_b</span> <span class="ow">and</span> <span class="n">p3</span> <span class="ow">in</span> <span class="n">r_b</span><span class="p">:</span>
                    <span class="n">b3</span> <span class="o">=</span> <span class="n">r_b</span><span class="p">[</span><span class="n">p3</span><span class="p">]</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="n">Basic</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">a3</span><span class="p">,</span> <span class="n">b3</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">c</span>

        <span class="k">return</span> <span class="n">Basic</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="Basic.compare_pretty"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.basic.Basic.compare_pretty">[docs]</a>    <span class="k">def</span> <span class="nf">compare_pretty</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Is a &gt; b in the sense of ordering in printing?</span>

<span class="sd">        ::</span>

<span class="sd">          yes ..... return 1</span>
<span class="sd">          no ...... return -1</span>
<span class="sd">          equal ... return 0</span>

<span class="sd">        Strategy:</span>

<span class="sd">        It uses Basic.compare as a fallback, but improves it in many cases,</span>
<span class="sd">        like x**3, x**4, O(x**3) etc. In those simple cases, it just parses the</span>
<span class="sd">        expression and returns the &quot;sane&quot; ordering such as::</span>

<span class="sd">          1 &lt; x &lt; x**2 &lt; x**3 &lt; O(x**4) etc.</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">        &gt;&gt;&gt; from sympy import Basic, Number</span>
<span class="sd">        &gt;&gt;&gt; Basic._compare_pretty(x, x**2)</span>
<span class="sd">        -1</span>
<span class="sd">        &gt;&gt;&gt; Basic._compare_pretty(x**2, x**2)</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; Basic._compare_pretty(x**3, x**2)</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; Basic._compare_pretty(Number(1, 2), Number(1, 3))</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; Basic._compare_pretty(Number(0), Number(-1))</span>
<span class="sd">        1</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">_sympify</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">SympifyError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">_sympify</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">SympifyError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c"># both objects are non-SymPy</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Basic</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">Basic</span><span class="p">)):</span>
            <span class="k">return</span> <span class="nb">cmp</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Basic</span><span class="p">):</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>   <span class="c"># other &lt; sympy</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">Basic</span><span class="p">):</span>
            <span class="k">return</span> <span class="o">+</span><span class="mi">1</span>   <span class="c"># sympy &gt; other</span>

        <span class="c"># now both objects are from SymPy, so we can proceed to usual comparison</span>
        <span class="k">return</span> <span class="nb">cmp</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">sort_key</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">sort_key</span><span class="p">())</span>
</div>
    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Basic.fromiter"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.basic.Basic.fromiter">[docs]</a>    <span class="k">def</span> <span class="nf">fromiter</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">assumptions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new object from an iterable.</span>

<span class="sd">        This is a convenience function that allows one to create objects from</span>
<span class="sd">        any iterable, without having to convert to a list or tuple first.</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Tuple</span>
<span class="sd">        &gt;&gt;&gt; Tuple.fromiter(i for i in xrange(5))</span>
<span class="sd">        (0, 1, 2, 3, 4)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="o">*</span><span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="o">**</span><span class="n">assumptions</span><span class="p">)</span>
</div>
    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Basic.class_key"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.basic.Basic.class_key">[docs]</a>    <span class="k">def</span> <span class="nf">class_key</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Nice order of classes. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">__name__</span>
</div>
<div class="viewcode-block" id="Basic.sort_key"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.basic.Basic.sort_key">[docs]</a>    <span class="k">def</span> <span class="nf">sort_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a sort key.</span>

<span class="sd">        **Examples**</span>

<span class="sd">        &gt;&gt;&gt; from sympy.core import Basic, S, I</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>

<span class="sd">        &gt;&gt;&gt; sorted([S(1)/2, I, -I], key=lambda x: x.sort_key())</span>
<span class="sd">        [1/2, -I, I]</span>

<span class="sd">        &gt;&gt;&gt; S(&quot;[x, 1/x, 1/x**2, x**2, x**(1/2), x**(1/4), x**(3/2)]&quot;)</span>
<span class="sd">        [x, 1/x, x**(-2), x**2, x**(1/2), x**(1/4), x**(3/2)]</span>
<span class="sd">        &gt;&gt;&gt; sorted(_, key=lambda x: x.sort_key())</span>
<span class="sd">        [x**(-2), 1/x, x**(1/4), x**(1/2), x, x**(3/2), x**2]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.core.singleton</span> <span class="kn">import</span> <span class="n">S</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_key</span><span class="p">(),</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">),</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="o">.</span><span class="n">sort_key</span><span class="p">(),</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>

</div>
    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;a == b  -&gt; Compare two symbolic trees and see whether they are equal</span>

<span class="sd">           this is the same as:</span>

<span class="sd">             a.compare(b) == 0</span>

<span class="sd">           but faster</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">other</span> <span class="o">=</span> <span class="n">_sympify</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">SympifyError</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>    <span class="c"># sympy != other</span>

            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">False</span>

        <span class="c"># type(self) == type(other)</span>
        <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hashable_content</span><span class="p">()</span>
        <span class="n">ot</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_hashable_content</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">st</span> <span class="o">==</span> <span class="n">ot</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assume_type_keys</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_assume_type_keys</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;a != b  -&gt; Compare two symbolic trees and see whether they are different</span>

<span class="sd">           this is the same as:</span>

<span class="sd">             a.compare(b) != 0</span>

<span class="sd">           but faster</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">other</span> <span class="o">=</span> <span class="n">_sympify</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">SympifyError</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>     <span class="c"># sympy != other</span>

            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">True</span>

        <span class="c"># type(self) == type(other)</span>
        <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hashable_content</span><span class="p">()</span>
        <span class="n">ot</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_hashable_content</span><span class="p">()</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">st</span> <span class="o">!=</span> <span class="n">ot</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assume_type_keys</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">_assume_type_keys</span>

<div class="viewcode-block" id="Basic.dummy_eq"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.basic.Basic.dummy_eq">[docs]</a>    <span class="k">def</span> <span class="nf">dummy_eq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">symbol</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compare two expressions and handle dummy symbols.</span>

<span class="sd">        **Examples**</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Dummy</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>

<span class="sd">        &gt;&gt;&gt; u = Dummy(&#39;u&#39;)</span>

<span class="sd">        &gt;&gt;&gt; (u**2 + 1).dummy_eq(x**2 + 1)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; (u**2 + 1) == (x**2 + 1)</span>
<span class="sd">        False</span>

<span class="sd">        &gt;&gt;&gt; (u**2 + y).dummy_eq(x**2 + y, x)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; (u**2 + y).dummy_eq(x**2 + y, y)</span>
<span class="sd">        False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dummy_symbols</span> <span class="o">=</span> <span class="p">[</span> <span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">is_Dummy</span> <span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">dummy_symbols</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">dummy_symbols</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">dummy</span> <span class="o">=</span> <span class="n">dummy_symbols</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;only one dummy symbol allowed on the left-hand side&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">symbol</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">symbols</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">free_symbols</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">symbols</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">symbol</span> <span class="o">=</span> <span class="n">symbols</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;specify a symbol in which expressions should be compared&quot;</span><span class="p">)</span>

        <span class="n">tmp</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">.</span><span class="n">__class__</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">dummy</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span>

    <span class="c"># Note, we always use the default ordering (lex) in __str__ and __repr__,</span>
    <span class="c"># regardless of the global setting.  See issue 2388.</span></div>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy.printing</span> <span class="kn">import</span> <span class="n">sstr</span>
        <span class="k">return</span> <span class="n">sstr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy.printing</span> <span class="kn">import</span> <span class="n">sstr</span>
        <span class="k">return</span> <span class="n">sstr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>

<div class="viewcode-block" id="Basic.atoms"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.basic.Basic.atoms">[docs]</a>    <span class="k">def</span> <span class="nf">atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">types</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the atoms that form the current object.</span>

<span class="sd">           By default, only objects that are truly atomic and can&#39;t</span>
<span class="sd">           be divided into smaller pieces are returned: symbols, numbers,</span>
<span class="sd">           and number symbols like I and pi. It is possible to request</span>
<span class="sd">           atoms of any type, however, as demonstrated below.</span>

<span class="sd">           Examples:</span>

<span class="sd">           &gt;&gt;&gt; from sympy import I, pi, sin</span>
<span class="sd">           &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">           &gt;&gt;&gt; (1 + x + 2*sin(y + I*pi)).atoms()</span>
<span class="sd">           set([1, 2, I, pi, x, y])</span>

<span class="sd">           If one or more types are given, the results will contain only</span>
<span class="sd">           those types of atoms.</span>

<span class="sd">           Examples:</span>

<span class="sd">           &gt;&gt;&gt; from sympy import Number, NumberSymbol, Symbol</span>
<span class="sd">           &gt;&gt;&gt; (1 + x + 2*sin(y + I*pi)).atoms(Symbol)</span>
<span class="sd">           set([x, y])</span>

<span class="sd">           &gt;&gt;&gt; (1 + x + 2*sin(y + I*pi)).atoms(Number)</span>
<span class="sd">           set([1, 2])</span>

<span class="sd">           &gt;&gt;&gt; (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol)</span>
<span class="sd">           set([1, 2, pi])</span>

<span class="sd">           &gt;&gt;&gt; (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol, I)</span>
<span class="sd">           set([1, 2, I, pi])</span>

<span class="sd">           Note that I (imaginary unit) and zoo (complex infinity) are special</span>
<span class="sd">           types of number symbols and are not part of the NumberSymbol class.</span>

<span class="sd">           The type can be given implicitly, too:</span>

<span class="sd">           &gt;&gt;&gt; (1 + x + 2*sin(y + I*pi)).atoms(x) # x is a Symbol</span>
<span class="sd">           set([x, y])</span>

<span class="sd">           Be careful to check your assumptions when using the implicit option</span>
<span class="sd">           since ``S(1).is_Integer = True`` but ``type(S(1))`` is ``One``, a special type</span>
<span class="sd">           of sympy atom, while ``type(S(2))`` is type ``Integer`` and will find all</span>
<span class="sd">           integers in an expression:</span>

<span class="sd">           &gt;&gt;&gt; from sympy import S</span>
<span class="sd">           &gt;&gt;&gt; (1 + x + 2*sin(y + I*pi)).atoms(S(1))</span>
<span class="sd">           set([1])</span>

<span class="sd">           &gt;&gt;&gt; (1 + x + 2*sin(y + I*pi)).atoms(S(2))</span>
<span class="sd">           set([1, 2])</span>

<span class="sd">           Finally, arguments to atoms() can select more than atomic atoms: any</span>
<span class="sd">           sympy type (loaded in core/__init__.py) can be listed as an argument</span>
<span class="sd">           and those types of &quot;atoms&quot; as found in scanning the arguments of the</span>
<span class="sd">           expression recursively:</span>

<span class="sd">           &gt;&gt;&gt; from sympy import Function, Mul</span>
<span class="sd">           &gt;&gt;&gt; (1 + x + 2*sin(y + I*pi)).atoms(Function)</span>
<span class="sd">           set([sin(y + I*pi)])</span>

<span class="sd">           &gt;&gt;&gt; (1 + x + 2*sin(y + I*pi)).atoms(Mul)</span>
<span class="sd">           set([I*pi, 2*sin(y + I*pi)])</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_atoms</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">typ</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Helper function for recursively denesting atoms&quot;&quot;&quot;</span>

            <span class="n">result</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Basic</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Atom</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">typ</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c"># if we haven&#39;t specified types</span>
                    <span class="k">return</span> <span class="nb">set</span><span class="p">([</span><span class="n">expr</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">typ</span><span class="p">):</span>
                            <span class="n">result</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                        <span class="c">#one or more types is in implicit form</span>
                        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">typ</span><span class="p">:</span>
                            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
                                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
                                    <span class="n">result</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">t</span><span class="p">)):</span>
                                    <span class="n">result</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

                <span class="nb">iter</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">iter_basic_args</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">iterable</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
                <span class="nb">iter</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">__iter__</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">iter</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">_atoms</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">typ</span><span class="p">))</span>

            <span class="k">return</span> <span class="n">result</span>

        <span class="k">return</span> <span class="n">_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="n">types</span><span class="p">)</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Basic.free_symbols"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.basic.Basic.free_symbols">[docs]</a>    <span class="k">def</span> <span class="nf">free_symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return from the atoms of self those which are free symbols.</span>

<span class="sd">        For most expressions, all symbols are free symbols. For some classes</span>
<span class="sd">        this is not true. e.g. Integrals use Symbols for the dummy variables</span>
<span class="sd">        which are bound variables, so Integral has a method to return all symbols</span>
<span class="sd">        except those. Derivative keeps track of symbols with respect to which it</span>
<span class="sd">        will perform a derivative; those are bound variables, too, so it has</span>
<span class="sd">        its own symbols method.</span>

<span class="sd">        Any other method that uses bound variables should implement a symbols</span>
<span class="sd">        method.&quot;&quot;&quot;</span>
        <span class="n">union</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">union</span>
        <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">union</span><span class="p">,</span> <span class="p">[</span><span class="n">arg</span><span class="o">.</span><span class="n">free_symbols</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">],</span> <span class="nb">set</span><span class="p">())</span>
</div>
    <span class="k">def</span> <span class="nf">is_hypergeometric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy.simplify</span> <span class="kn">import</span> <span class="n">hypersimp</span>
        <span class="k">return</span> <span class="n">hypersimp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="Basic.is_number"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.basic.Basic.is_number">[docs]</a>    <span class="k">def</span> <span class="nf">is_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns ``True`` if &#39;self&#39; is a number.</span>

<span class="sd">           &gt;&gt;&gt; from sympy import log, Integral</span>
<span class="sd">           &gt;&gt;&gt; from sympy.abc import x, y</span>

<span class="sd">           &gt;&gt;&gt; x.is_number</span>
<span class="sd">           False</span>
<span class="sd">           &gt;&gt;&gt; (2*x).is_number</span>
<span class="sd">           False</span>
<span class="sd">           &gt;&gt;&gt; (2 + log(2)).is_number</span>
<span class="sd">           True</span>
<span class="sd">           &gt;&gt;&gt; (2 + Integral(2, x)).is_number</span>
<span class="sd">           False</span>
<span class="sd">           &gt;&gt;&gt; (2 + Integral(2, (x, 1, 2))).is_number</span>
<span class="sd">           True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># should be overriden by subclasses</span>
        <span class="k">return</span> <span class="bp">False</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Basic.func"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.basic.Basic.func">[docs]</a>    <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The top-level function in an expression.</span>

<span class="sd">        The following should hold for all objects::</span>

<span class="sd">            &gt;&gt; x == x.func(*x.args)</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">        &gt;&gt;&gt; a = 2*x</span>
<span class="sd">        &gt;&gt;&gt; a.func</span>
<span class="sd">        &lt;class &#39;sympy.core.mul.Mul&#39;&gt;</span>
<span class="sd">        &gt;&gt;&gt; a.args</span>
<span class="sd">        (2, x)</span>
<span class="sd">        &gt;&gt;&gt; a.func(*a.args)</span>
<span class="sd">        2*x</span>
<span class="sd">        &gt;&gt;&gt; a == a.func(*a.args)</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Basic.args"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.basic.Basic.args">[docs]</a>    <span class="k">def</span> <span class="nf">args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a tuple of arguments of &#39;self&#39;.</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import symbols, cot</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>

<span class="sd">        &gt;&gt;&gt; cot(x).args</span>
<span class="sd">        (x,)</span>

<span class="sd">        &gt;&gt;&gt; cot(x).args[0]</span>
<span class="sd">        x</span>

<span class="sd">        &gt;&gt;&gt; (x*y).args</span>
<span class="sd">        (x, y)</span>

<span class="sd">        &gt;&gt;&gt; (x*y).args[1]</span>
<span class="sd">        y</span>

<span class="sd">        Note for developers: Never use self._args, always use self.args.</span>
<span class="sd">        Only when you are creating your own new function, use _args</span>
<span class="sd">        in the __new__. Don&#39;t override .args() from Basic (so that it&#39;s</span>
<span class="sd">        easy to change the interface in the future if needed).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_args</span>
</div>
<div class="viewcode-block" id="Basic.iter_basic_args"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.basic.Basic.iter_basic_args">[docs]</a>    <span class="k">def</span> <span class="nf">iter_basic_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterates arguments of &#39;self&#39;.</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">        &gt;&gt;&gt; a = 2*x</span>
<span class="sd">        &gt;&gt;&gt; a.iter_basic_args()</span>
<span class="sd">        &lt;tupleiterator object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; list(a.iter_basic_args())</span>
<span class="sd">        [2, x]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Basic.as_poly"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.basic.Basic.as_poly">[docs]</a>    <span class="k">def</span> <span class="nf">as_poly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">gens</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts ``self`` to a polynomial or returns ``None``.</span>

<span class="sd">           &gt;&gt;&gt; from sympy import Poly, sin</span>
<span class="sd">           &gt;&gt;&gt; from sympy.abc import x, y</span>

<span class="sd">           &gt;&gt;&gt; print (x**2 + x*y).as_poly()</span>
<span class="sd">           Poly(x**2 + x*y, x, y, domain=&#39;ZZ&#39;)</span>

<span class="sd">           &gt;&gt;&gt; print (x**2 + x*y).as_poly(x, y)</span>
<span class="sd">           Poly(x**2 + x*y, x, y, domain=&#39;ZZ&#39;)</span>

<span class="sd">           &gt;&gt;&gt; print (x**2 + sin(y)).as_poly(x, y)</span>
<span class="sd">           None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.polys</span> <span class="kn">import</span> <span class="n">Poly</span><span class="p">,</span> <span class="n">PolynomialError</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">poly</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">gens</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">poly</span><span class="o">.</span><span class="n">is_Poly</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">poly</span>
        <span class="k">except</span> <span class="n">PolynomialError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
</div>
<div class="viewcode-block" id="Basic.subs"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.basic.Basic.subs">[docs]</a>    <span class="k">def</span> <span class="nf">subs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Substitutes an expression.</span>

<span class="sd">        Calls either _subs_old_new, _subs_dict or _subs_list depending</span>
<span class="sd">        if you give it two arguments (old, new), a dictionary or a list.</span>

<span class="sd">        Examples:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import pi</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; (1 + x*y).subs(x, pi)</span>
<span class="sd">        pi*y + 1</span>
<span class="sd">        &gt;&gt;&gt; (1 + x*y).subs({x:pi, y:2})</span>
<span class="sd">        1 + 2*pi</span>
<span class="sd">        &gt;&gt;&gt; (1 + x*y).subs([(x,pi), (y,2)])</span>
<span class="sd">        1 + 2*pi</span>

<span class="sd">        &gt;&gt;&gt; (x + y).subs([(y,x**2), (x,2)])</span>
<span class="sd">        6</span>
<span class="sd">        &gt;&gt;&gt; (x + y).subs([(x,2), (y,x**2)])</span>
<span class="sd">        x**2 + 2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sequence</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subs_dict</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">iterable</span><span class="p">(</span><span class="n">sequence</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subs_list</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Not an iterable container&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">old</span><span class="p">,</span> <span class="n">new</span> <span class="o">=</span> <span class="n">args</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subs_old_new</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;subs accepts either 1 or 2 arguments&quot;</span><span class="p">)</span>
</div>
    <span class="nd">@cacheit</span>
    <span class="k">def</span> <span class="nf">_subs_old_new</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Substitutes an expression old -&gt; new.&quot;&quot;&quot;</span>
        <span class="n">old</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">old</span><span class="p">)</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_subs</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_eval_subs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">old</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">new</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">arg</span><span class="o">.</span><span class="n">_eval_subs</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_subs_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequence</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs an order sensitive substitution from the</span>
<span class="sd">        input sequence list.</span>

<span class="sd">        Examples:</span>

<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; (x+y)._subs_list( [(x, 3),     (y, x**2)] )</span>
<span class="sd">        x**2 + 3</span>
<span class="sd">        &gt;&gt;&gt; (x+y)._subs_list( [(y, x**2),  (x, 3)   ] )</span>
<span class="sd">        12</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s">&#39;subs&#39;</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_subs_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequence</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Performs sequential substitution.</span>

<span class="sd">           Given a collection of key, value pairs, which correspond to</span>
<span class="sd">           old and new expressions respectively,  substitute all given</span>
<span class="sd">           pairs handling properly all overlapping keys  (according to</span>
<span class="sd">           &#39;in&#39; relation).</span>

<span class="sd">           We have to use naive O(n**2) sorting algorithm, as &#39;in&#39;</span>
<span class="sd">           gives only partial order and all asymptotically faster</span>
<span class="sd">           fail (depending on the initial order).</span>

<span class="sd">           &gt;&gt;&gt; from sympy import sqrt, sin, cos, exp</span>
<span class="sd">           &gt;&gt;&gt; from sympy.abc import x, y</span>

<span class="sd">           &gt;&gt;&gt; from sympy.abc import a, b, c, d, e</span>

<span class="sd">           &gt;&gt;&gt; A = (sqrt(sin(2*x)), a)</span>
<span class="sd">           &gt;&gt;&gt; B = (sin(2*x), b)</span>
<span class="sd">           &gt;&gt;&gt; C = (cos(2*x), c)</span>
<span class="sd">           &gt;&gt;&gt; D = (x, d)</span>
<span class="sd">           &gt;&gt;&gt; E = (exp(x), e)</span>

<span class="sd">           &gt;&gt;&gt; expr = sqrt(sin(2*x))*sin(exp(x)*x)*cos(2*x) + sin(2*x)</span>

<span class="sd">           &gt;&gt;&gt; expr._subs_dict([A,B,C,D,E])</span>
<span class="sd">           a*c*sin(d*e) + b</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">sequence</span> <span class="o">=</span> <span class="n">sequence</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>

        <span class="n">subst</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">subst</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">pattern</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">expr</span><span class="p">:</span>
                    <span class="n">subst</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">subst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
        <span class="n">subst</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subs_list</span><span class="p">(</span><span class="n">subst</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">obj</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">True</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">obj</span> <span class="o">==</span> <span class="n">arg</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="nd">@cacheit</span>
<div class="viewcode-block" id="Basic.has"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.basic.Basic.has">[docs]</a>    <span class="k">def</span> <span class="nf">has</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">patterns</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test whether any subexpression matches any of the patterns.</span>

<span class="sd">        Examples:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import sin, S</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y, z</span>
<span class="sd">        &gt;&gt;&gt; (x**2 + sin(x*y)).has(z)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; (x**2 + sin(x*y)).has(x, y, z)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; x.has(x)</span>
<span class="sd">        True</span>

<span class="sd">        Note that ``expr.has(*patterns)`` is exactly equivalent to</span>
<span class="sd">        ``any(expr.has(p) for p in patterns)``. In particular, ``False`` is</span>
<span class="sd">        returned when the list of patterns is empty.</span>

<span class="sd">        &gt;&gt;&gt; x.has()</span>
<span class="sd">        False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">test</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Basic</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">search</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">test</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">expr</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">False</span>
            <span class="k">elif</span> <span class="n">test</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">search</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">test</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">iter_basic_args</span><span class="p">())</span>

        <span class="k">def</span> <span class="nf">_match</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">BasicType</span><span class="p">):</span>
                <span class="k">return</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>

        <span class="n">patterns</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">sympify</span><span class="p">,</span> <span class="n">patterns</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_match</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">patterns</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Basic.replace"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.basic.Basic.replace">[docs]</a>    <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="nb">map</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace matching subexpressions of ``self`` with ``value``.</span>

<span class="sd">        If ``map = True`` then also return the mapping {old: new} where ``old``</span>
<span class="sd">        was a sub-expression found with query and ``new`` is the replacement</span>
<span class="sd">        value for it.</span>

<span class="sd">        Traverses an expression tree and performs replacement of matching</span>
<span class="sd">        subexpressions from the bottom to the top of the tree. The list of</span>
<span class="sd">        possible combinations of queries and replacement values is listed</span>
<span class="sd">        below:</span>

<span class="sd">        1.1. type -&gt; type</span>
<span class="sd">             obj.replace(sin, tan)</span>
<span class="sd">        1.2. type -&gt; func</span>
<span class="sd">             obj.replace(sin, lambda expr, arg: ...)</span>

<span class="sd">        2.1. expr -&gt; expr</span>
<span class="sd">             obj.replace(sin(a), tan(a))</span>
<span class="sd">        2.2. expr -&gt; func</span>
<span class="sd">             obj.replace(sin(a), lambda a: ...)</span>

<span class="sd">        3.1. func -&gt; func</span>
<span class="sd">             obj.replace(lambda expr: ..., lambda expr: ...)</span>

<span class="sd">        Examples:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import log, sin, cos, tan, Wild</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>

<span class="sd">        &gt;&gt;&gt; f = log(sin(x)) + tan(sin(x**2))</span>

<span class="sd">        &gt;&gt;&gt; f.replace(sin, cos)</span>
<span class="sd">        log(cos(x)) + tan(cos(x**2))</span>
<span class="sd">        &gt;&gt;&gt; f.replace(sin, lambda arg: sin(2*arg))</span>
<span class="sd">        log(sin(2*x)) + tan(sin(2*x**2))</span>

<span class="sd">        &gt;&gt;&gt; sin(x).replace(sin, cos, map=True)</span>
<span class="sd">        (cos(x), {sin(x): cos(x)})</span>

<span class="sd">        &gt;&gt;&gt; a = Wild(&#39;a&#39;)</span>

<span class="sd">        &gt;&gt;&gt; f.replace(sin(a), cos(a))</span>
<span class="sd">        log(cos(x)) + tan(cos(x**2))</span>
<span class="sd">        &gt;&gt;&gt; f.replace(sin(a), lambda a: sin(2*a))</span>
<span class="sd">        log(sin(2*x)) + tan(sin(2*x**2))</span>

<span class="sd">        &gt;&gt;&gt; g = 2*sin(x**3)</span>

<span class="sd">        &gt;&gt;&gt; g.replace(lambda expr: expr.is_Number, lambda expr: expr**2)</span>
<span class="sd">        4*sin(x**9)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
            <span class="n">_query</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">expr</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">query</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
                <span class="n">_value</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">expr</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span> <span class="n">value</span><span class="p">(</span><span class="o">*</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">callable</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="n">_value</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">expr</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span> <span class="n">value</span><span class="p">(</span><span class="o">*</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;given a type, replace() expects another type or a callable&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">Basic</span><span class="p">):</span>
            <span class="n">_query</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">expr</span><span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Basic</span><span class="p">):</span>
                <span class="n">_value</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">expr</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span> <span class="n">value</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">callable</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="n">_value</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">expr</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span> <span class="n">value</span><span class="p">(</span><span class="o">**</span><span class="nb">dict</span><span class="p">([</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()</span> <span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;given an expression, replace() expects another expression or a callable&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">callable</span><span class="p">(</span><span class="n">query</span><span class="p">):</span>
            <span class="n">_query</span> <span class="o">=</span> <span class="n">query</span>

            <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="n">_value</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">expr</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span> <span class="n">value</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;given a callable, replace() expects another callable&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;first argument to replace() must be a type, an expression or a callable&quot;</span><span class="p">)</span>

        <span class="n">mapping</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">def</span> <span class="nf">rec_replace</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
            <span class="n">args</span><span class="p">,</span> <span class="n">construct</span> <span class="o">=</span> <span class="p">[],</span> <span class="bp">False</span>

            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">rec_replace</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">construct</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">arg</span>

                <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">construct</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">_query</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">_value</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

                    <span class="k">if</span> <span class="nb">map</span><span class="p">:</span>
                        <span class="n">mapping</span><span class="p">[</span><span class="n">expr</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

                    <span class="k">return</span> <span class="n">value</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">None</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">rec_replace</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">map</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">mapping</span>
</div>
<div class="viewcode-block" id="Basic.find"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.basic.Basic.find">[docs]</a>    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find all subexpressions matching a query. &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
            <span class="n">_query</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">expr</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">query</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">Basic</span><span class="p">):</span>
            <span class="n">_query</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">expr</span><span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_query</span> <span class="o">=</span> <span class="n">query</span>

        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">def</span> <span class="nf">rec_find</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">_query</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="n">rec_find</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

        <span class="n">rec_find</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">group</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
                    <span class="n">groups</span><span class="p">[</span><span class="n">result</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">groups</span><span class="p">[</span><span class="n">result</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="k">return</span> <span class="n">groups</span>
</div>
<div class="viewcode-block" id="Basic.count"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.basic.Basic.count">[docs]</a>    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Count the number of matching subexpressions. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
</div>
<div class="viewcode-block" id="Basic.matches"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.basic.Basic.matches">[docs]</a>    <span class="k">def</span> <span class="nf">matches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">repl_dict</span><span class="o">=</span><span class="p">{},</span> <span class="n">evaluate</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper method for match() - switches the pattern and expr.</span>

<span class="sd">        Can be used to solve linear equations:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Symbol, Wild, Integer</span>
<span class="sd">        &gt;&gt;&gt; a,b = map(Symbol, &#39;ab&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x = Wild(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; (a+b*x).matches(Integer(0))</span>
<span class="sd">        {x_: -a/b}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">evaluate</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">repl_dict</span><span class="p">)</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">repl_dict</span><span class="p">)</span>

        <span class="n">expr</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">expr</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">repl_dict</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">repl_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">other_arg</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">arg</span> <span class="o">==</span> <span class="n">other_arg</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">other_arg</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="n">d</span>
</div>
<div class="viewcode-block" id="Basic.match"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.basic.Basic.match">[docs]</a>    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pattern matching.</span>

<span class="sd">        Wild symbols match all.</span>

<span class="sd">        Return ``None`` when expression (self) does not match</span>
<span class="sd">        with pattern. Otherwise return a dictionary such that::</span>

<span class="sd">          pattern.subs(self.match(pattern)) == self</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import symbols, Wild</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; p = Wild(&quot;p&quot;)</span>
<span class="sd">        &gt;&gt;&gt; q = Wild(&quot;q&quot;)</span>
<span class="sd">        &gt;&gt;&gt; r = Wild(&quot;r&quot;)</span>
<span class="sd">        &gt;&gt;&gt; e = (x+y)**(x+y)</span>
<span class="sd">        &gt;&gt;&gt; e.match(p**p)</span>
<span class="sd">        {p_: x + y}</span>
<span class="sd">        &gt;&gt;&gt; e.match(p**q)</span>
<span class="sd">        {p_: x + y, q_: x + y}</span>
<span class="sd">        &gt;&gt;&gt; e = (2*x)**2</span>
<span class="sd">        &gt;&gt;&gt; e.match(p*q**r)</span>
<span class="sd">        {p_: 4, q_: x, r_: 2}</span>
<span class="sd">        &gt;&gt;&gt; (p*q**r).subs(e.match(p*q**r))</span>
<span class="sd">        4*x**2</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pattern</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pattern</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Basic.count_ops"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.basic.Basic.count_ops">[docs]</a>    <span class="k">def</span> <span class="nf">count_ops</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">visual</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;wrapper for count_ops that returns the operation count.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">count_ops</span>
        <span class="k">return</span> <span class="n">count_ops</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">visual</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">count_ops</span><span class="p">(</span><span class="n">visual</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Basic.doit"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.basic.Basic.doit">[docs]</a>    <span class="k">def</span> <span class="nf">doit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate objects that are not evaluated by default like limits,</span>
<span class="sd">           integrals, sums and products. All objects of this kind will be</span>
<span class="sd">           evaluated recursively, unless some species were excluded via &#39;hints&#39;</span>
<span class="sd">           or unless the &#39;deep&#39; hint was set to &#39;False&#39;.</span>

<span class="sd">           &gt;&gt;&gt; from sympy import Integral</span>
<span class="sd">           &gt;&gt;&gt; from sympy.abc import x, y</span>

<span class="sd">           &gt;&gt;&gt; 2*Integral(x, x)</span>
<span class="sd">           2*Integral(x, x)</span>

<span class="sd">           &gt;&gt;&gt; (2*Integral(x, x)).doit()</span>
<span class="sd">           x**2</span>

<span class="sd">           &gt;&gt;&gt; (2*Integral(x, x)).doit(deep = False)</span>
<span class="sd">           2*Integral(x, x)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">hints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;deep&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
            <span class="n">terms</span> <span class="o">=</span> <span class="p">[</span> <span class="n">term</span><span class="o">.</span><span class="n">doit</span><span class="p">(</span><span class="o">**</span><span class="n">hints</span><span class="p">)</span> <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="p">]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">terms</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
</div>
    <span class="k">def</span> <span class="nf">_eval_rewrite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">sargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="p">[</span> <span class="n">t</span><span class="o">.</span><span class="n">_eval_rewrite</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">sargs</span> <span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">terms</span><span class="p">)</span>

<div class="viewcode-block" id="Basic.rewrite"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.basic.Basic.rewrite">[docs]</a>    <span class="k">def</span> <span class="nf">rewrite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rewrites expression containing applications of functions</span>
<span class="sd">           of one kind in terms of functions of different kind. For</span>
<span class="sd">           example you can rewrite trigonometric functions as complex</span>
<span class="sd">           exponentials or combinatorial functions as gamma function.</span>

<span class="sd">           As a pattern this function accepts a list of functions to</span>
<span class="sd">           to rewrite (instances of DefinedFunction class). As rule</span>
<span class="sd">           you can use string or a destination function instance (in</span>
<span class="sd">           this case rewrite() will use the str() function).</span>

<span class="sd">           There is also possibility to pass hints on how to rewrite</span>
<span class="sd">           the given expressions. For now there is only one such hint</span>
<span class="sd">           defined called &#39;deep&#39;. When &#39;deep&#39; is set to False it will</span>
<span class="sd">           forbid functions to rewrite their contents.</span>

<span class="sd">           &gt;&gt;&gt; from sympy import sin, exp, I</span>
<span class="sd">           &gt;&gt;&gt; from sympy.abc import x, y</span>

<span class="sd">           &gt;&gt;&gt; sin(x).rewrite(sin, exp)</span>
<span class="sd">           -I*(exp(I*x) - exp(-I*x))/2</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Atom</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pattern</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">rule</span> <span class="o">=</span> <span class="s">&#39;_eval_rewrite_as_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">pattern</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_rewrite</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">iterable</span><span class="p">(</span><span class="n">pattern</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">pattern</span> <span class="o">=</span> <span class="n">pattern</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="n">pattern</span> <span class="o">=</span> <span class="p">[</span> <span class="n">p</span><span class="o">.</span><span class="n">__class__</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pattern</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">]</span>

                <span class="k">if</span> <span class="n">pattern</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_rewrite</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">pattern</span><span class="p">),</span> <span class="n">rule</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span>
</div></div>
<div class="viewcode-block" id="Atom"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.basic.Atom">[docs]</a><span class="k">class</span> <span class="nc">Atom</span><span class="p">(</span><span class="n">Basic</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A parent class for atomic things. An atom is an expression with no subexpressions.</span>

<span class="sd">    Examples: Symbol, Number, Rational, Integer, ...</span>
<span class="sd">    But not: Add, Mul, Pow, ...</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">is_Atom</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">matches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">repl_dict</span><span class="o">=</span><span class="p">{},</span> <span class="n">evaluate</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">expr</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">repl_dict</span>

    <span class="k">def</span> <span class="nf">_eval_subs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">old</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">new</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">doit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="o">==</span> <span class="n">obj</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">class_key</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">__name__</span>

    <span class="k">def</span> <span class="nf">sort_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy.core</span> <span class="kn">import</span> <span class="n">S</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_key</span><span class="p">(),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="p">,)),</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="o">.</span><span class="n">sort_key</span><span class="p">(),</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SymPy v0.7.1 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../sympy.html" >sympy</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2008, 2009, 2010, 2011 SymPy Development Team.
      Last updated on Jul 29, 2011.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>